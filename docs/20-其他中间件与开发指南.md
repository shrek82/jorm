# 20. 其他中间件与开发指南

除了数据缓存，JORM 还内置了其他实用的中间件，用于提升系统的稳定性、可观测性和健壮性。此外，JORM 提供了简单易用的接口，支持开发者编写自定义中间件。

## 其他内置中间件

### 1. SlowLog (慢查询日志)

SlowLog 中间件用于记录执行时间超过指定阈值的 SQL 查询，帮助开发者定位性能瓶颈。

**使用方法**：

```go
import "github.com/shrek82/jorm/middleware"

// 记录执行超过 200ms 的查询
// 可选：传入自定义 logger 函数，默认为 log.Printf
db.Use(middleware.NewSlowLog(200 * time.Millisecond))
```

**效果**：
当查询耗时超过 200ms 时，日志中会输出 SQL 语句、参数和具体耗时。

### 2. CircuitBreaker (熔断器)

CircuitBreaker 中间件用于防止数据库故障导致应用雪崩。当错误率达到阈值时，熔断器会打开，暂时拦截所有请求，直到探测到数据库恢复。

**使用方法**：

```go
// 参数 1: 失败阈值 (连续失败多少次触发熔断)
// 参数 2: 冷却时间 (熔断后多久尝试恢复)
db.Use(middleware.NewCircuitBreaker(3, 10*time.Second))
```

**工作机制**：
-   **Closed (关闭)**：正常状态，请求通过。
-   **Open (打开)**：连续失败 N 次后进入此状态，所有请求直接返回 `ErrCircuitOpen` 错误，不请求数据库。
-   **Half-Open (半开)**：冷却时间过后，允许一个请求通过。如果成功，重置为 Closed；如果失败，继续保持 Open。

### 3. Tracing (分布式追踪)

Tracing 中间件用于集成分布式追踪系统（如 Jaeger, Zipkin）。它遵循 OpenTelemetry 标准（或类似的 Span 概念）。

**使用方法**：

```go
// 开启追踪
db.Use(middleware.NewTracing("jorm-service"))
```

**注意**：使用 Tracing 中间件时，必须在查询方法中传入包含 Trace Context 的 `context.Context`。

```go
// 必须传入 context
db.WithContext(ctx).Find(&users)
```

## 自定义中间件开发

JORM 的中间件基于接口设计，非常易于扩展。核心接口定义在 `core` 包中。

### 接口定义

```go
// QueryMiddleware 定义了查询中间件的接口
type QueryMiddleware interface {
    // Name 返回中间件名称
    Name() string
    
    // Init 初始化中间件，通常用于验证配置或启动后台任务
    Init(db *DB) error
    
    // Process 处理查询请求
    // ctx: 上下文
    // query: 查询对象，包含 SQL 和参数
    // next: 下一个处理函数（可能是下一个中间件，也可能是最终的执行器）
    Process(ctx context.Context, query *Query, next QueryFunc) (*Result, error)
    
    // Shutdown 关闭中间件，释放资源
    Shutdown() error
}

// QueryFunc 定义了查询执行函数的签名
type QueryFunc func(ctx context.Context, query *Query) (*Result, error)
```

### 开发示例：SQL 统计中间件

下面演示如何开发一个简单的中间件，用于统计执行的 SQL 总数。

```go
package mymiddleware

import (
    "context"
    "fmt"
    "sync/atomic"
    "github.com/shrek82/jorm/core"
)

type SQLCounter struct {
    count int64
}

func NewSQLCounter() *SQLCounter {
    return &SQLCounter{}
}

func (m *SQLCounter) Name() string {
    return "SQLCounter"
}

func (m *SQLCounter) Init(db *core.DB) error {
    fmt.Println("SQLCounter initialized")
    return nil
}

func (m *SQLCounter) Process(ctx context.Context, query *core.Query, next core.QueryFunc) (*core.Result, error) {
    // 1. 请求前逻辑
    atomic.AddInt64(&m.count, 1)
    current := atomic.LoadInt64(&m.count)
    fmt.Printf("[SQLCounter] Total queries: %d\n", current)

    // 2. 调用下一个处理器 (必须调用，否则链条断裂)
    res, err := next(ctx, query)

    // 3. 请求后逻辑 (可选)
    // if err != nil { ... }

    return res, err
}

func (m *SQLCounter) Shutdown() error {
    return nil
}

// GetCount 获取统计值
func (m *SQLCounter) GetCount() int64 {
    return atomic.LoadInt64(&m.count)
}
```

### 注册与使用

```go
func main() {
    db, _ := jorm.Open("sqlite3", "test.db")
    
    counter := mymiddleware.NewSQLCounter()
    db.Use(counter)
    
    // 执行查询，控制台会打印计数
    var users []User
    db.Find(&users)
}
```

### 开发建议

1.  **线程安全**：`Process` 方法会被并发调用，确保内部状态（如 map、计数器）是线程安全的。
2.  **错误处理**：尽量透传 `next` 返回的错误，除非你有特殊的错误处理逻辑。
3.  **Context 传递**：始终将 `ctx` 传递给 `next` 函数，以支持超时控制和追踪。
4.  **性能**：中间件处于核心调用链上，避免在 `Process` 中执行耗时操作（除非是像 SlowLog 那样的异步记录）。
