# 插入操作

本指南详细介绍如何在 jorm 中插入数据到数据库。

## 基础插入

### 插入单条记录

使用 `Insert()` 方法插入单条记录：

```go
user := &User{
    Name:  "Alice",
    Email: "alice@example.com",
    Age:   25,
}

id, err := db.Model(user).Insert(user)
if err != nil {
    panic(err)
}

fmt.Printf("插入成功，ID: %d\n", id)
```

### 使用指针

```go
user := &User{
    Name:  "Alice",
    Email: "alice@example.com",
}

id, err := db.Model(&User{}).Insert(user)
if err != nil {
    panic(err)
}
```

## 批量插入

### BatchInsert - 批量插入

使用 `BatchInsert()` 方法批量插入多条记录：

```go
users := []*User{
    {Name: "Alice", Email: "alice@example.com", Age: 25},
    {Name: "Bob", Email: "bob@example.com", Age: 30},
    {Name: "Charlie", Email: "charlie@example.com", Age: 28},
}

count, err := db.Model(&User{}).BatchInsert(users)
if err != nil {
    panic(err)
}

fmt.Printf("批量插入 %d 条记录\n", count)
```

### 批量插入性能优化

批量插入比循环插入性能更好：

```go
// 推荐：批量插入
users := []*User{...}
count, err := db.Model(&User{}).BatchInsert(users)

// 不推荐：循环插入
for _, user := range users {
    _, err := db.Model(&User{}).Insert(user)
    if err != nil {
        return err
    }
}
```

## 处理 NULL 值

### 使用指针类型

使用指针类型处理可空字段：

```go
type User struct {
    ID     int64   `jorm:"pk;auto"`
    Name   string  `jorm:"notnull"`
    Age    *int    `jorm:"type:int"`       // 可空
    Phone  *string `jorm:"type:varchar(20)"`  // 可空
}

// 插入 NULL 值
user := &User{
    Name:  "Alice",
    Age:   nil,    // 插入 NULL
    Phone: nil,   // 插入 NULL
}

id, err := db.Model(user).Insert(user)
```

### 插入非空值

```go
age := 25
phone := "1234567890"

user := &User{
    Name:  "Alice",
    Age:   &age,   // 插入 25
    Phone: &phone, // 插入 "1234567890"
}

id, err := db.Model(user).Insert(user)
```

## 自动字段

### 自动时间

使用 `auto_time` 标签自动设置创建时间：

```go
type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string
    CreatedAt time.Time `jorm:"auto_time"`  // 插入时自动设置
}

user := &User{Name: "Alice"}
id, _ := db.Model(user).Insert(user)

// CreatedAt 会自动设置为当前时间
fmt.Println(user.CreatedAt)
```

### 默认值

使用 `default` 标签设置默认值：

```go
type User struct {
    ID     int64  `jorm:"pk;auto"`
    Name   string `jorm:"notnull"`
    Status string `jorm:"default:'active'"`  // 默认值
    Age    int    `jorm:"default:0"`        // 默认值
}

user := &User{Name: "Alice"}
id, _ := db.Model(user).Insert(user)

// Status 和 Age 会使用默认值
```

## 插入后获取 ID

### 返回值获取

`Insert()` 方法返回插入记录的 ID：

```go
user := &User{Name: "Alice"}
id, err := db.Model(user).Insert(user)
if err != nil {
    panic(err)
}

fmt.Printf("插入的记录 ID: %d\n", id)
```

### 使用 AfterInsert 钩子

```go
type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string
    CreatedAt time.Time `jorm:"auto_time"`
}

func (u *User) AfterInsert(id int64) error {
    u.ID = id  // 更新结构体的 ID
    fmt.Printf("记录已插入，ID: %d\n", id)
    return nil
}

user := &User{Name: "Alice"}
id, _ := db.Model(user).Insert(user)
fmt.Printf("结构体中的 ID: %d\n", user.ID)  // 现在有值了
```

## 完整示例

### 创建用户

```go
type User struct {
    ID        int64     `jorm:"pk;auto column:id"`
    Username  string    `jorm:"size:50 unique notnull column:username"`
    Email     string    `jorm:"size:100 unique notnull column:email"`
    Password  string    `jorm:"size:255 notnull column:password"`
    FirstName string    `jorm:"size:50 column:first_name"`
    LastName  string    `jorm:"size:50 column:last_name"`
    Age       int       `jorm:"type:int default:0 column:age"`
    Status    string    `jorm:"size:20 default:'active' column:status"`
    CreatedAt time.Time `jorm:"auto_time column:created_at"`
}

func CreateUser(db *core.DB, username, email, password string) (int64, error) {
    user := &User{
        Username: username,
        Email:    email,
        Password: password,  // 应该先哈希
        Status:   "active",
    }

    id, err := db.Model(user).Insert(user)
    if err != nil {
        return 0, fmt.Errorf("创建用户失败: %w", err)
    }

    return id, nil
}

// 使用
id, err := CreateUser(db, "alice", "alice@example.com", "hashed_password")
if err != nil {
    panic(err)
}
fmt.Printf("用户创建成功，ID: %d\n", id)
```

### 批量创建用户

```go
func BatchCreateUsers(db *core.DB, users []*User) (int64, error) {
    if len(users) == 0 {
        return 0, fmt.Errorf("用户列表不能为空")
    }

    count, err := db.Model(&User{}).BatchInsert(users)
    if err != nil {
        return 0, fmt.Errorf("批量创建用户失败: %w", err)
    }

    return count, nil
}

// 使用
users := []*User{
    {Username: "alice", Email: "alice@example.com", Password: "pass1"},
    {Username: "bob", Email: "bob@example.com", Password: "pass2"},
    {Username: "charlie", Email: "charlie@example.com", Password: "pass3"},
}

count, err := BatchCreateUsers(db, users)
if err != nil {
    panic(err)
}
fmt.Printf("批量创建 %d 个用户\n", count)
```

## 错误处理

### 处理唯一约束冲突

```go
user := &User{
    Username: "alice",  // 假设已经存在
    Email:    "alice@example.com",
}

id, err := db.Model(user).Insert(user)
if err != nil {
    if errors.Is(err, core.ErrDuplicateKey) {
        fmt.Println("用户名或邮箱已存在")
    } else {
        fmt.Printf("插入失败: %v\n", err)
    }
    return
}

fmt.Printf("插入成功，ID: %d\n", id)
```

### 处理外键约束

```go
type Order struct {
    ID     int64   `jorm:"pk;auto"`
    UserID int64   `jorm:"fk:User.ID"`
    Amount float64
}

order := &Order{
    UserID: 9999,  // 假设用户不存在
    Amount: 100.0,
}

id, err := db.Model(order).Insert(order)
if err != nil {
    if errors.Is(err, core.ErrForeignKey) {
        fmt.Println("用户不存在")
    } else {
        fmt.Printf("插入失败: %v\n", err)
    }
    return
}

fmt.Printf("订单创建成功，ID: %d\n", id)
```

## 验证数据

### 使用验证器

详见 [数据验证](./11-数据验证.md)

```go
type User struct {
    ID    int64  `jorm:"pk;auto"`
    Name  string `jorm:"size:100 notnull"`
    Email string `jorm:"size:100 unique"`
    Age   int
}

func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Name":  {jorm.Required, jorm.MinLen(2)},
        "Email": {jorm.Required, jorm.Email},
        "Age":   {jorm.Required, jorm.Range(18, 100)},
    }.Validate
}

// 带验证的插入
user := &User{Name: "Alice", Email: "alice@example.com", Age: 25}
id, err := db.Model(user).InsertWithValidator(user, user.GetValidator())
if err != nil {
    if validationErrs, ok := err.(jorm.ValidationErrors); ok {
        fmt.Println("验证失败:", validationErrs)
        return
    }
    panic(err)
}

fmt.Printf("插入成功，ID: %d\n", id)
```

## 使用事务插入

详见 [事务处理](./08-事务处理.md)

```go
err := db.Transaction(func(tx *core.Tx) error {
    // 插入用户
    user := &User{Name: "Alice", Email: "alice@example.com"}
    userID, err := tx.Model(user).Insert(user)
    if err != nil {
        return err  // 自动回滚
    }

    // 插入用户的第一个订单
    order := &Order{
        UserID: userID,
        Amount: 100.0,
    }
    _, err = tx.Model(order).Insert(order)
    if err != nil {
        return err  // 自动回滚
    }

    return nil  // 自动提交
})

if err != nil {
    panic(err)
}

fmt.Println("用户和订单创建成功")
```

## 原生 SQL 插入

详见 [原生 SQL](./15-原生SQL.md)

```go
// 使用原生 SQL 插入
affected, err := db.Raw(`
    INSERT INTO users (name, email, created_at)
    VALUES (?, ?, ?)
`, "Alice", "alice@example.com", time.Now()).Exec()

if err != nil {
    panic(err)
}

fmt.Printf("影响行数: %d\n", affected)
```

## 特殊场景

### 插入 JSON 数据

```go
type User struct {
    ID       int64  `jorm:"pk;auto"`
    Name     string
    Metadata string `jorm:"type:json"`
}

// 插入 JSON 数据
metadata := `{"age": 25, "city": "Beijing"}`
user := &User{
    Name:     "Alice",
    Metadata: metadata,
}

id, err := db.Model(user).Insert(user)
```

### 插入二进制数据

```go
type User struct {
    ID     int64  `jorm:"pk;auto"`
    Name   string
    Avatar []byte `jorm:"type:blob"`
}

// 读取图片文件
avatarData, err := os.ReadFile("avatar.jpg")
if err != nil {
    panic(err)
}

// 插入二进制数据
user := &User{
    Name:   "Alice",
    Avatar: avatarData,
}

id, err := db.Model(user).Insert(user)
```

### 条件插入（INSERT ... ON DUPLICATE KEY UPDATE）

```go
// 使用原生 SQL 实现
affected, err := db.Raw(`
    INSERT INTO users (name, email, updated_at)
    VALUES (?, ?, ?)
    ON DUPLICATE KEY UPDATE
        name = VALUES(name),
        updated_at = VALUES(updated_at)
`, "Alice", "alice@example.com", time.Now()).Exec()
```

## 性能优化

### 批量插入优化

对于大量数据，使用批量插入：

```go
// 推荐：批量插入
func InsertManyUsers(users []*User) error {
    const batchSize = 1000

    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }

        batch := users[i:end]
        _, err := db.Model(&User{}).BatchInsert(batch)
        if err != nil {
            return err
        }
    }

    return nil
}

// 不推荐：循环插入
func InsertManyUsersSlow(users []*User) error {
    for _, user := range users {
        _, err := db.Model(&User{}).Insert(user)
        if err != nil {
            return err
        }
    }
    return nil
}
```

### 禁用日志提高性能

批量插入时可以临时禁用日志：

```go
import "github.com/shrek82/jorm/logger"

// 保存当前日志器
currentLogger := db.GetLogger()

// 禁用日志
db.SetLogger(nil)

// 执行批量插入
count, err := db.Model(&User{}).BatchInsert(users)

// 恢复日志器
db.SetLogger(currentLogger)
```

## 常见问题

### Q: 如何获取插入后的自增 ID？

A: `Insert()` 方法会返回插入记录的 ID：

```go
id, err := db.Model(user).Insert(user)
fmt.Printf("插入的 ID: %d\n", id)
```

### Q: 如何处理唯一键冲突？

A: 检查 `ErrDuplicateKey` 错误：

```go
id, err := db.Model(user).Insert(user)
if err != nil {
    if errors.Is(err, core.ErrDuplicateKey) {
        fmt.Println("记录已存在")
    }
}
```

### Q: 批量插入数量有限制吗？

A: 建议每次批量插入不超过 1000 条记录，超过这个数量可以分批插入：

```go
const batchSize = 1000
for i := 0; i < len(users); i += batchSize {
    end := i + batchSize
    if end > len(users) {
        end = len(users)
    }
    db.Model(&User{}).BatchInsert(users[i:end])
}
```

### Q: 如何插入 NULL 值？

A: 使用指针类型：

```go
type User struct {
    Age *int `jorm:"type:int"`
}

user := &User{
    Age: nil,  // 插入 NULL
}
```

## 最佳实践

### 1. 使用批量插入

```go
// 推荐
db.Model(&User{}).BatchInsert(users)

// 不推荐
for _, user := range users {
    db.Model(&User{}).Insert(user)
}
```

### 2. 始终检查错误

```go
// 推荐
id, err := db.Model(user).Insert(user)
if err != nil {
    return fmt.Errorf("插入失败: %w", err)
}

// 不推荐
id, _ := db.Model(user).Insert(user)
```

### 3. 使用事务处理相关数据

```go
// 推荐：使用事务
err := db.Transaction(func(tx *core.Tx) error {
    // 插入用户
    userID, _ := tx.Model(user).Insert(user)

    // 插入订单
    order.UserID = userID
    _, err := tx.Model(order).Insert(order)
    return err
})

// 不推荐：不使用事务
userID, _ := db.Model(user).Insert(user)
order.UserID = userID
db.Model(order).Insert(order)
```

### 4. 验证数据后再插入

```go
// 推荐：先验证
if err := user.GetValidator()(user); err != nil {
    return err
}
id, err := db.Model(user).Insert(user)

// 不推荐：不验证直接插入
id, err := db.Model(user).Insert(user)
```

## 下一步

- [更新操作](./06-更新操作.md) - 学习如何更新数据
- [删除操作](./07-删除操作.md) - 学习如何删除数据
- [事务处理](./08-事务处理.md) - 学习事务处理
- [数据验证](./11-数据验证.md) - 学习数据验证
