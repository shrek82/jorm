# 日志配置

本指南详细介绍如何在 jorm 中配置和使用日志功能。

## 基本用法

### 使用默认日志

```go
import "github.com/shrek82/jorm/logger"

// 使用标准日志（默认 LevelError 级别）
db.SetLogger(logger.NewStdLogger())
```

### 设置日志级别

```go
// 创建日志器
log := logger.NewStdLogger()

// 设置日志级别
log.SetLevel(logger.LevelInfo)  // 选项：LevelDebug, LevelInfo, LevelWarn, LevelError

// 应用到 DB
db.SetLogger(log)
```

## 日志级别

### Debug - 调试级别

```go
log.SetLevel(logger.LevelDebug)
```

输出所有 SQL 语句、参数以及详细执行信息，适合开发调试。

```
[SQL] SELECT * FROM users WHERE id = ? [1]
[SQL] INSERT INTO users (name, email) VALUES (?, ?) ['Alice', 'alice@example.com']
```

### Info - 信息级别

```go
log.SetLevel(logger.LevelInfo)
```

输出常规运行信息，不包含 SQL 语句。

### Warn - 警告级别

```go
log.SetLevel(logger.LevelWarn)
```

只输出警告和错误信息。

### Error - 错误级别

```go
log.SetLevel(logger.LevelError)
```

只输出错误信息，默认级别。

## 日志格式

### 文本格式（默认）

```go
log.SetFormat(logger.FormatText)
```

输出示例：
```
[2024-01-01 12:00:00] [DEBUG] SELECT * FROM users WHERE id = ? [1]
```

### JSON 格式

```go
log.SetFormat(logger.FormatJSON)
```

输出示例：
```json
{"time":"2024-01-01T12:00:00Z","level":"DEBUG","sql":"SELECT * FROM users WHERE id = ?","args":[1]}
```

## 自定义日志器

### 实现日志接口

```go
type MyLogger struct {
    // 自定义字段
}

func (l *MyLogger) Log(level logger.LogLevel, sql string, args ...any) {
    // 自定义日志输出
    prefix := "[SQL]"
    switch level {
    case logger.LevelDebug:
        prefix = "[DEBUG]"
    case logger.LevelInfo:
        prefix = "[INFO]"
    case logger.LevelWarn:
        prefix = "[WARN]"
    case logger.LevelError:
        prefix = "[ERROR]"
    }

    fmt.Printf("%s %s %v\n", prefix, sql, args)
}

// 使用
db.SetLogger(&MyLogger{})
```

### 集成第三方日志库

#### 集成 zap

```go
import (
    "go.uber.org/zap"
    "github.com/shrek82/jorm/logger"
)

type ZapLogger struct {
    logger *zap.Logger
}

func NewZapLogger(zapLogger *zap.Logger) *ZapLogger {
    return &ZapLogger{logger: zapLogger}
}

func (l *ZapLogger) Log(level logger.LogLevel, sql string, args ...any) {
    fields := []zap.Field{
        zap.String("sql", sql),
        zap.Any("args", args),
    }

    switch level {
    case logger.LevelDebug:
        l.logger.Debug("SQL executed", fields...)
    case logger.LevelInfo:
        l.logger.Info("SQL executed", fields...)
    case logger.LevelWarn:
        l.logger.Warn("SQL executed", fields...)
    case logger.LevelError:
        l.logger.Error("SQL executed", fields...)
    }
}

// 使用
zapLogger, _ := zap.NewProduction()
db.SetLogger(NewZapLogger(zapLogger))
```

#### 集成 logrus

```go
import (
    "github.com/sirupsen/logrus"
    "github.com/shrek82/jorm/logger"
)

type LogrusLogger struct {
    logger *logrus.Logger
}

func NewLogrusLogger(logrusLogger *logrus.Logger) *LogrusLogger {
    return &LogrusLogger{logger: logrusLogger}
}

func (l *LogrusLogger) Log(level logger.LogLevel, sql string, args ...any) {
    entry := l.logger.WithFields(logrus.Fields{
        "sql":  sql,
        "args": args,
    })

    switch level {
    case logger.LevelDebug:
        entry.Debug("SQL executed")
    case logger.LevelInfo:
        entry.Info("SQL executed")
    case logger.LevelWarn:
        entry.Warn("SQL executed")
    case logger.LevelError:
        entry.Error("SQL executed")
    }
}

// 使用
logrusLogger := logrus.New()
db.SetLogger(NewLogrusLogger(logrusLogger))
```

## 开发环境配置

### 详细日志

```go
import "github.com/shrek82/jorm/logger"

// 创建日志器
log := logger.NewStdLogger()

// 设置 Debug 级别以查看 SQL
log.SetLevel(logger.LevelDebug)

// 使用文本格式
log.SetFormat(logger.FormatText)

// 应用到 DB
db.SetLogger(log)

// 现在所有 SQL 都会打印
db.Model(&User{}).Where("id = ?", 1).First(&user)
// 输出: [DEBUG] SELECT * FROM users WHERE id = ? [1]
```

## 生产环境配置

### 只记录错误

```go
// 创建日志器
log := logger.NewStdLogger()

// 设置 Error 级别
log.SetLevel(logger.LevelError)

// 使用 JSON 格式（适合日志收集）
log.SetFormat(logger.FormatJSON)

// 应用到 DB
db.SetLogger(log)
```

### 结合文件日志

```go
import (
    "os"
    "github.com/shrek82/jorm/logger"
)

// 创建日志文件
file, err := os.OpenFile("jorm.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
if err != nil {
    panic(err)
}

// 创建自定义日志器
type FileLogger struct {
    file *os.File
}

func (l *FileLogger) Log(level logger.LogLevel, sql string, args ...any) {
    // 只记录错误级别
    if level != logger.LevelError {
        return
    }

    timestamp := time.Now().Format("2006-01-02 15:04:05")
    fmt.Fprintf(l.file, "[%s] [ERROR] %s %v\n", timestamp, sql, args)
}

// 使用
db.SetLogger(&FileLogger{file: file})
```

## 查看最后执行的 SQL

```go
// 执行查询
db.Model(&User{}).Where("id = ?", 1).First(&user)

// 获取最后执行的 SQL
sql, args := db.LastSQL()
fmt.Printf("SQL: %s\n", sql)
fmt.Printf("Args: %v\n", args)
```

## 禁用日志

```go
// 禁用日志
db.SetLogger(nil)
```

适合性能测试或不想记录日志的场景。

## 最佳实践

### 1. 开发环境使用 Debug 级别

```go
// 开发环境
log := logger.NewStdLogger()
log.SetLevel(logger.LevelDebug)
db.SetLogger(log)
```

### 2. 生产环境使用 Error 级别

```go
// 生产环境
log := logger.NewStdLogger()
log.SetLevel(logger.LevelError)
log.SetFormat(logger.FormatJSON)
db.SetLogger(log)
```

### 3. 集成应用日志框架

```go
// 推荐集成应用的日志框架
db.SetLogger(&MyAppLogger{})
```

### 4. 记录慢查询

```go
type SlowQueryLogger struct {
    threshold time.Duration
}

func (l *SlowQueryLogger) Log(level logger.LogLevel, sql string, args ...any) {
    start := time.Now()

    // 执行 SQL
    // ...

    duration := time.Since(start)
    if duration > l.threshold {
        fmt.Printf("Slow query (%v): %s %v\n", duration, sql, args)
    }
}
```

## 下一步

- [Context支持](./14-Context支持.md) - 学习 Context 支持
- [错误处理](./16-错误处理.md) - 学习错误处理
- [最佳实践](./18-最佳实践.md) - 了解更多最佳实践
