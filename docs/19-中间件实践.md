# JORM 中间件实践

本文档通过实战示例，介绍如何开发、注册和使用 JORM 的查询中间件 (Query Middleware)。

## 中间件接口

JORM 的中间件基于洋葱模型（Onion Architecture），通过拦截查询执行流程来实现功能扩展。

```go
// 核心接口定义
type QueryMiddleware interface {
    Component // 继承 Component 接口 (Name, Init, Shutdown)
    Process(ctx context.Context, query *Query, next QueryFunc) (*Result, error)
}
```

## 实战 1：慢查询日志中间件 (Slow Query Logger)

这个中间件会记录执行时间超过设定阈值的 SQL 查询。

### 1. 定义结构体

```go
import (
    "context"
    "log"
    "os"
    "time"
    "github.com/shrek82/jorm"
)

type SlowQueryLogger struct {
    Threshold time.Duration
    Logger    *log.Logger
    Filename  string   // 可选：日志文件路径
    file      *os.File // 内部使用：文件句柄
}
```

### 2. 实现 Component 接口

```go
func (s *SlowQueryLogger) Name() string {
    return "slow_query_logger"
}

func (s *SlowQueryLogger) Init(db *jorm.DB) error {
    if s.Threshold == 0 {
        s.Threshold = 200 * time.Millisecond // 默认 200ms
    }

    // 如果配置了文件名，则将日志写入文件
    if s.Filename != "" {
        file, err := os.OpenFile(s.Filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil {
            return err
        }
        s.file = file
        s.Logger = log.New(file, "", log.LstdFlags)
    } else if s.Logger == nil {
        // 否则使用默认日志记录器
        s.Logger = log.Default()
    }
    
    return nil
}

func (s *SlowQueryLogger) Shutdown() error {
    // 如果打开了文件，需要关闭
    if s.file != nil {
        return s.file.Close()
    }
    return nil
}
```

### 3. 实现 Process 方法

```go
func (s *SlowQueryLogger) Process(ctx context.Context, query *jorm.Query, next jorm.QueryFunc) (*jorm.Result, error) {
    start := time.Now()
    
    // 继续执行后续中间件和最终查询
    result, err := next(ctx, query)
    
    duration := time.Since(start)
    
    // 检查是否超过阈值
    if duration > s.Threshold {
        s.Logger.Printf("[SLOW QUERY] Duration: %v | SQL: %s | Args: %v", duration, query.SQL, query.Args)
    }
    
    return result, err
}
```

## 实战 2：简单的熔断器 (Circuit Breaker)

当数据库错误率过高时，暂时阻止新的查询，保护数据库。

```go
type SimpleCircuitBreaker struct {
    FailureCount int
    MaxFailures  int
    ResetTimeout time.Duration
    
    lastFailure  time.Time
    mu           sync.Mutex
}

func (cb *SimpleCircuitBreaker) Name() string { return "circuit_breaker" }

func (cb *SimpleCircuitBreaker) Init(db *jorm.DB) error {
    if cb.MaxFailures == 0 {
        cb.MaxFailures = 5
    }
    return nil
}

func (cb *SimpleCircuitBreaker) Shutdown() error { return nil }

func (cb *SimpleCircuitBreaker) Process(ctx context.Context, query *jorm.Query, next jorm.QueryFunc) (*jorm.Result, error) {
    cb.mu.Lock()
    if cb.FailureCount >= cb.MaxFailures {
        if time.Since(cb.lastFailure) > cb.ResetTimeout {
            // 尝试恢复
            cb.FailureCount = 0
        } else {
            cb.mu.Unlock()
            return nil, fmt.Errorf("circuit breaker open: too many failures")
        }
    }
    cb.mu.Unlock()

    // 执行查询
    result, err := next(ctx, query)

    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err != nil {
        cb.FailureCount++
        cb.lastFailure = time.Now()
    } else {
        // 成功则重置计数（简单策略）
        cb.FailureCount = 0
    }

    return result, err
}
```

## 注册与使用

在应用启动时，将自定义中间件注册到 DB 实例中。

```go
func main() {
    db, _ := jorm.Open("mysql", "dsn...")

    // 注册中间件
    // 注意顺序：熔断器应该在最外层（先执行），慢查询日志在内层
    db.Use(
        &SimpleCircuitBreaker{
            MaxFailures:  3,
            ResetTimeout: 10 * time.Second,
        },
        &SlowQueryLogger{
            Threshold: 100 * time.Millisecond,
            Filename:  "slow_queries.log", // 将慢查询日志保存到文件
        },
    )

    // 正常使用
    var user User
    db.Model(&user).Where("id = ?", 1).Find()
}
```

## 最佳实践

1.  **保持轻量**：中间件会拦截每一次查询，因此应避免在 `Process` 中执行耗时的计算或阻塞操作（除非那是你的目的，如限流）。
2.  **错误处理**：始终检查 `next()` 返回的错误。
3.  **Context 传递**：确保将 `ctx` 传递给 `next()`，并在需要时利用 Context 传递元数据（如 TraceID）。
4.  **线程安全**：中间件实例是全局共享的，如果包含状态（如熔断器的计数器），必须确保并发安全（使用 `sync.Mutex` 或 `atomic`）。
