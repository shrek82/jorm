# 19. 中间件实践：数据缓存

JORM 提供了强大的中间件机制，允许开发者在查询执行流程中插入自定义逻辑。其中，数据缓存是最常用的中间件场景之一。通过合理使用缓存，可以显著减少数据库负载，提升应用性能。

## 缓存中间件概览

JORM 内置了三种标准的缓存中间件，支持多级缓存策略：

1.  **MemoryCache**：基于内存的 L1 缓存，速度最快，但容量受限且重启丢失。
2.  **FileCache**：基于文件系统的 L2 缓存，持久化存储，容量较大。
3.  **RedisCache**：基于 Redis 的分布式缓存，适合集群部署。

## 启用缓存

要使用缓存，首先需要在数据库连接对象上注册相应的中间件。JORM 支持通过 `Use` 方法注册多个中间件，它们会按照注册顺序依次执行（类似于洋葱模型）。

### 注册中间件

```go
import (
    "github.com/shrek82/jorm"
    "github.com/shrek82/jorm/middleware"
    "time"
)

func main() {
    db, _ := jorm.Open("mysql", "user:pass@tcp(127.0.0.1:3306)/dbname")

    // 1. 注册内存缓存 (L1)
    memCache := middleware.NewMemoryCache(5 * time.Minute) // 默认过期时间
    
    // 2. 注册文件缓存 (L2)
    fileCache := middleware.NewFileCache("./cache_data", 1 * time.Hour)
    
    // 3. 注册 Redis 缓存 (L3 - 分布式)
    // 需要先配置 Redis 客户端
    // 可选传入默认过期时间 (例如 30 分钟)
    // redisCache := middleware.NewRedisCache(&redis.Options{Addr: "localhost:6379"}, 30 * time.Minute)

    // 按顺序注册：Memory -> File -> Redis
    // 查询时：先查 Memory，没命中查 File，没命中查 Redis，最后查 DB
    // 回填时：DB 返回 -> 写入 Redis -> 写入 File -> 写入 Memory
    db.Use(memCache, fileCache)
}
```

## 使用缓存

注册中间件后，默认情况下查询**不会**走缓存，除非显式调用 `.Cache()` 方法。这是一种显式优于隐式的设计，防止缓存被滥用。

### 基本用法

注册中间件后，默认情况下查询**不会**走缓存，除非显式调用 `.Cache()` 方法。

**优先级规则**：
1.  **最高优先级**：`Cache(time)` 中指定的时长。
2.  **次优先级**：`Cache(-1)` 显式指定永久缓存。
3.  **默认优先级**：`Cache()` (无参) 使用中间件创建时指定的默认时长 (`defaultTTL`)。
4.  **强制默认**：如果既未指定 TTL 也未配置默认 TTL，则强制缓存 **24小时**。

```go
var user User

// 1. 使用默认过期时间
// 优先级：中间件配置的 DefaultTTL > 强制 24小时
db.Table("users").Where("id = ?", 1).Cache().First(&user)

// 2. 指定本次查询的过期时间 (优先级最高)
// 例如：缓存 10 分钟，忽略中间件的默认配置
db.Table("users").Where("id = ?", 1).Cache(10 * time.Minute).First(&user)

// 3. 永久缓存
// 必须显式传入 -1
db.Table("users").Where("code = ?", "CONFIG_001").Cache(-1).First(&user)
```

### 多级缓存工作原理

当注册了多个缓存中间件（如 Memory + File）时：

1.  **读取流程**：
    - JORM 首先询问第一个中间件（Memory）：有数据吗？
    - 如果 Memory 有，直接返回（速度极快）。
    - 如果 Memory 没有，JORM 询问第二个中间件（File）：有数据吗？
    - 如果 File 有，返回数据，并且**自动回填**到 Memory 中，以便下次直接命中 Memory。
    - 如果所有缓存层都没有，最后执行数据库查询。

2.  **写入流程**：
    - 数据库查询返回结果后。
    - 结果会**逆序**写入所有缓存层（File -> Memory）。

这种机制确保了热点数据总是保留在最快的缓存层中。

## 内置缓存中间件详解

### 1. MemoryCache (内存缓存)

适用于高频访问、数据量较小且允许丢失的数据。

-   **创建**：`middleware.NewMemoryCache(defaultTTL ...time.Duration)`
-   **特点**：
    -   使用 `sync.Map` 或 `map + RWMutex` 实现，线程安全。
    -   内置清理协程，定期清理过期数据。
    -   速度最快（微秒级）。

### 2. FileCache (文件缓存)

适用于数据量较大、需要持久化但不需要跨机器共享的数据。

-   **创建**：`middleware.NewFileCache(dirPath string, defaultTTL ...time.Duration)`
-   **特点**：
    -   将查询结果序列化为 JSON 存储在指定目录。
    -   文件名通常是 SQL 语句和参数的哈希值。
    -   支持跨重启存在。

### 3. RedisCache (Redis 缓存)

适用于分布式系统，多个应用实例共享缓存。

-   **创建**：`middleware.NewRedisCache(options *redis.Options, defaultTTL ...time.Duration)`
    -   也支持传入默认缓存失效时间。
-   **依赖**：需要引入 `github.com/go-redis/redis/v8`。
-   **特点**：
    -   支持设置 TTL。
    -   利用 Redis 的高性能和持久化特性。
    -   **优先级说明**：所有 `Cache()` 可选传入缓存时间。如果传入参数，该时间优先级最高（覆盖默认 TTL）。

```go
// 示例：创建带有 10 分钟默认过期时间的 Redis 缓存
redisCache := middleware.NewRedisCache(&redis.Options{
    Addr: "localhost:6379",
}, 10*time.Minute)

// 使用默认时间 (10分钟)
db.Table("users").Cache().Find(&users)

// 覆盖默认时间 (1小时)
db.Table("users").Cache(1*time.Hour).Find(&users)
```

## 注意事项

1.  **缓存失效**：目前 JORM 的缓存主要是基于 TTL（时间）失效。如果手动更新了数据库，缓存不会自动失效（除非在业务逻辑中手动处理，或者等待过期）。因此，**不建议对实时性要求极高的数据使用长缓存**。
2.  **结果一致性**：使用 `Cache()` 时，请确保你的查询结果是可以被序列化的（通常是结构体或基本类型切片）。
3.  **调试**：可以通过开启 Debug 日志级别来观察缓存命中情况（取决于中间件的具体实现日志）。
