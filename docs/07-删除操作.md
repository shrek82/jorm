# 删除操作

本指南详细介绍如何在 jorm 中删除数据库中的数据。

## 基础删除

### 删除单条记录

使用 `Delete()` 方法删除记录：

```go
affected, err := db.Model(&User{}).
    Where("id = ?", 1).
    Delete()
if err != nil {
    panic(err)
}

fmt.Printf("删除了 %d 条记录\n", affected)
```

### 删除多条记录

```go
// 删除年龄小于 18 的用户
affected, err := db.Model(&User{}).
    Where("age < ?", 18).
    Delete()
if err != nil {
    panic(err)
}

fmt.Printf("删除了 %d 条记录\n", affected)
```

## 条件删除

### WHERE 条件

```go
// 根据条件删除
affected, err := db.Model(&User{}).
    Where("status = ?", "deleted").
    Delete()
```

### OR 条件

```go
// 删除多个条件匹配的记录
affected, err := db.Model(&User{}).
    Where("status = ?", "deleted").
    OrWhere("age < ?", 18).
    Delete()
```

### IN 条件

```go
// 删除多个 ID 的记录
affected, err := db.Model(&User{}).
    WhereIn("id", []int64{1, 2, 3}).
    Delete()
```

## 删除所有记录

### 删除表中所有数据

```go
// 删除所有用户（谨慎使用）
affected, err := db.Model(&User{}).Delete()
if err != nil {
    panic(err)
}

fmt.Printf("删除了 %d 条记录\n", affected)
```

### 使用 TRUNCATE 清空表

```go
// 使用原生 SQL 清空表（更快）
affected, err := db.Raw("TRUNCATE TABLE users").Exec()
if err != nil {
    panic(err)
}
```

## 软删除

### 使用软删除

软删除通过设置删除标记而不是真正删除记录：

```go
type User struct {
    ID        int64      `jorm:"pk;auto"`
    Name      string
    DeletedAt *time.Time `jorm:"type:datetime"`
}
```

### 软删除实现

```go
func SoftDeleteUser(db *core.DB, id int64) error {
    now := time.Now()
    affected, err := db.Model(&User{}).
        Where("id = ?", id).
        Update(map[string]any{
            "deleted_at": &now,
        })
    if err != nil {
        return fmt.Errorf("软删除失败: %w", err)
    }

    if affected == 0 {
        return fmt.Errorf("用户不存在")
    }

    return nil
}

// 使用
err := SoftDeleteUser(db, 1)
if err != nil {
    panic(err)
}
```

### 查询未删除的记录

```go
// 只查询未删除的记录
var users []User
err := db.Model(&User{}).
    Where("deleted_at IS NULL").
    Find(&users)
```

### 恢复软删除的记录

```go
func RestoreUser(db *core.DB, id int64) error {
    affected, err := db.Model(&User{}).
        Where("id = ?", id).
        Update(map[string]any{
            "deleted_at": nil,
        })
    if err != nil {
        return fmt.Errorf("恢复失败: %w", err)
    }

    if affected == 0 {
        return fmt.Errorf("用户不存在")
    }

    return nil
}
```

### 物理删除软删除的记录

```go
func PermanentlyDelete(db *core.DB, id int64) error {
    affected, err := db.Model(&User{}).
        Where("id = ?", id).
        Where("deleted_at IS NOT NULL").
        Delete()
    if err != nil {
        return fmt.Errorf("永久删除失败: %w", err)
    }

    if affected == 0 {
        return fmt.Errorf("用户不存在或未被软删除")
    }

    return nil
}
```

## 使用事务删除

详见 [事务处理](./08-事务处理.md)

```go
err := db.Transaction(func(tx *core.Tx) error {
    // 删除用户
    _, err := tx.Model(&User{}).
        Where("id = ?", 1).
        Delete()
    if err != nil {
        return err  // 自动回滚
    }

    // 删除用户的订单
    _, err = tx.Model(&Order{}).
        Where("user_id = ?", 1).
        Delete()
    if err != nil {
        return err  // 自动回滚
    }

    return nil  // 自动提交
})

if err != nil {
    panic(err)
}

fmt.Println("删除成功")
```

## 原生 SQL 删除

详见 [原生 SQL](./15-原生SQL.md)

```go
affected, err := db.Raw(`
    DELETE FROM users
    WHERE id = ?
`, 1).Exec()

if err != nil {
    panic(err)
}

fmt.Printf("删除了 %d 条记录\n", affected)
```

## 级联删除

### 使用外键约束

```go
type Order struct {
    ID     int64 `jorm:"pk;auto"`
    UserID int64 `jorm:"fk:User.ID ON DELETE CASCADE"`
    Amount float64
}
```

删除用户时，相关订单会自动被删除。

### 手动级联删除

```go
func DeleteUserWithOrders(db *core.DB, userID int64) error {
    err := db.Transaction(func(tx *core.Tx) error {
        // 先删除订单
        _, err := tx.Model(&Order{}).
            Where("user_id = ?", userID).
            Delete()
        if err != nil {
            return err
        }

        // 再删除用户
        _, err = tx.Model(&User{}).
            Where("id = ?", userID).
            Delete()
        if err != nil {
            return err
        }

        return nil
    })

    return err
}

// 使用
err := DeleteUserWithOrders(db, 1)
if err != nil {
    panic(err)
}
```

## 完整示例

### 删除用户

```go
func DeleteUser(db *core.DB, id int64) error {
    affected, err := db.Model(&User{}).
        Where("id = ?", id).
        Delete()
    if err != nil {
        return fmt.Errorf("删除用户失败: %w", err)
    }

    if affected == 0 {
        return fmt.Errorf("用户不存在")
    }

    return nil
}

// 使用
err := DeleteUser(db, 1)
if err != nil {
    panic(err)
}
fmt.Println("删除成功")
```

### 批量删除

```go
func BatchDeleteUsers(db *core.DB, ids []int64) (int64, error) {
    if len(ids) == 0 {
        return 0, fmt.Errorf("ID 列表不能为空")
    }

    affected, err := db.Model(&User{}).
        WhereIn("id", ids).
        Delete()
    if err != nil {
        return 0, fmt.Errorf("批量删除失败: %w", err)
    }

    return affected, nil
}

// 使用
ids := []int64{1, 2, 3, 4, 5}
count, err := BatchDeleteUsers(db, ids)
if err != nil {
    panic(err)
}
fmt.Printf("删除了 %d 条记录\n", count)
```

### 按条件删除

```go
func DeleteByStatus(db *core.DB, status string) (int64, error) {
    affected, err := db.Model(&User{}).
        Where("status = ?", status).
        Delete()
    if err != nil {
        return 0, fmt.Errorf("按状态删除失败: %w", err)
    }

    return affected, nil
}

// 使用
count, err := DeleteByStatus(db, "deleted")
if err != nil {
    panic(err)
}
fmt.Printf("删除了 %d 条记录\n", count)
```

## 错误处理

### 检查是否删除成功

```go
affected, err := db.Model(&User{}).
    Where("id = ?", 1).
    Delete()
if err != nil {
    panic(err)
}

if affected == 0 {
    fmt.Println("记录不存在")
} else {
    fmt.Println("删除成功")
}
```

### 处理外键约束

```go
affected, err := db.Model(&User{}).
    Where("id = ?", 1).
    Delete()
if err != nil {
    if errors.Is(err, core.ErrForeignKey) {
        fmt.Println("无法删除：存在关联数据")
    } else {
        fmt.Printf("删除失败: %v\n", err)
    }
    return
}
```

## 性能优化

### 批量删除

```go
// 推荐：使用条件批量删除
affected, err := db.Model(&User{}).
    Where("created_at < ?", time.Now().AddDate(0, -6, 0)).
    Delete()

// 不推荐：循环删除
ids := []int64{1, 2, 3, 4, 5}
for _, id := range ids {
    db.Model(&User{}).Where("id = ?", id).Delete()
}
```

### 使用 TRUNCATE 清空大表

```go
// 推荐：清空大表使用 TRUNCATE
affected, err := db.Raw("TRUNCATE TABLE users").Exec()

// 不推荐：使用 DELETE 删除所有记录
db.Model(&User{}).Delete()
```

## 安全注意事项

### 1. 始终使用 WHERE 条件

```go
// 推荐：有 WHERE 条件
db.Model(&User{}).Where("id = ?", 1).Delete()

// 不推荐：没有 WHERE 条件会删除所有记录
db.Model(&User{}).Delete()
```

### 2. 检查影响行数

```go
affected, err := db.Model(&User{}).
    Where("id = ?", 1).
    Delete()
if affected == 0 {
    fmt.Println("记录不存在")
}
```

### 3. 使用事务处理级联删除

```go
// 推荐：使用事务
db.Transaction(func(tx *core.Tx) error {
    // 删除相关数据
    _, err := tx.Model(&Order{}).Where("user_id = ?", 1).Delete()
    if err != nil {
        return err
    }

    // 删除主数据
    _, err = tx.Model(&User{}).Where("id = ?", 1).Delete()
    return err
})

// 不推荐：不使用事务
db.Model(&Order{}).Where("user_id = ?", 1).Delete()
db.Model(&User{}).Where("id = ?", 1).Delete()
```

### 4. 考虑使用软删除

```go
// 推荐：使用软删除
now := time.Now()
db.Model(&User{}).Where("id = ?", 1).
    Update(map[string]any{"deleted_at": &now})

// 不推荐：直接物理删除
db.Model(&User{}).Where("id = ?", 1).Delete()
```

## 常见问题

### Q: 如何知道删除了多少条记录？

A: `Delete()` 方法返回影响的行数：

```go
affected, err := db.Model(&User{}).
    Where("id = ?", 1).
    Delete()
fmt.Printf("删除了 %d 条记录\n", affected)
```

### Q: 如何删除所有记录？

A: 不带 WHERE 条件即可：

```go
affected, err := db.Model(&User{}).Delete()
```

⚠️ 谨慎使用，会删除所有记录！

### Q: 如何实现软删除？

A: 使用 `deleted_at` 字段：

```go
type User struct {
    ID        int64      `jorm:"pk;auto"`
    Name      string
    DeletedAt *time.Time `jorm:"type:datetime"`
}

// 软删除
now := time.Now()
db.Model(&User{}).Where("id = ?", 1).
    Update(map[string]any{"deleted_at": &now})
```

### Q: 删除时如何处理关联数据？

A: 使用事务：

```go
db.Transaction(func(tx *core.Tx) error {
    // 先删除关联数据
    tx.Model(&Order{}).Where("user_id = ?", 1).Delete()

    // 再删除主数据
    tx.Model(&User{}).Where("id = ?", 1).Delete()

    return nil
})
```

## 最佳实践

### 1. 始终检查影响行数

```go
// 推荐
affected, err := db.Model(&User{}).
    Where("id = ?", 1).
    Delete()
if affected == 0 {
    return fmt.Errorf("记录不存在")
}

// 不推荐
db.Model(&User{}).Where("id = ?", 1).Delete()
```

### 2. 软删除优先

```go
// 推荐：软删除
now := time.Now()
db.Model(&User{}).Where("id = ?", 1).
    Update(map[string]any{"deleted_at": &now})

// 不推荐：物理删除
db.Model(&User{}).Where("id = ?", 1).Delete()
```

### 3. 使用事务处理级联删除

```go
// 推荐
db.Transaction(func(tx *core.Tx) error {
    tx.Model(&Order{}).Where("user_id = ?", 1).Delete()
    tx.Model(&User{}).Where("id = ?", 1).Delete()
    return nil
})

// 不推荐
db.Model(&Order{}).Where("user_id = ?", 1).Delete()
db.Model(&User{}).Where("id = ?", 1).Delete()
```

### 4. 批量删除使用条件

```go
// 推荐
db.Model(&User{}).Where("created_at < ?", time.Now().AddDate(-1, 0, 0)).Delete()

// 不推荐
users := getOldUsers()
for _, user := range users {
    db.Model(&User{}).Where("id = ?", user.ID).Delete()
}
```

## 下一步

- [事务处理](./08-事务处理.md) - 学习事务处理
- [关联关系](./10-关联关系.md) - 学习关联删除
- [性能优化](./17-性能优化.md) - 优化删除操作
