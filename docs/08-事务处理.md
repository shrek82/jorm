# 事务处理

本指南详细介绍如何在 jorm 中使用事务处理数据库操作，保证数据的一致性。

## 函数式事务（推荐）

### 基本用法

使用 `Transaction()` 方法执行事务：

```go
err := db.Transaction(func(tx *core.Tx) error {
    // 在事务中执行操作
    user := &User{Name: "Alice", Email: "alice@example.com"}
    id, err := tx.Model(user).Insert(user)
    if err != nil {
        return err  // 返回错误，自动回滚
    }

    // 插入订单
    order := &Order{
        UserID: id,
        Amount: 100.0,
    }
    _, err = tx.Model(order).Insert(order)
    if err != nil {
        return err  // 返回错误，自动回滚
    }

    return nil  // 返回 nil，自动提交
})

if err != nil {
    fmt.Printf("事务失败: %v\n", err)
} else {
    fmt.Println("事务成功提交")
}
```

### 事务工作原理

```go
// 1. 开始事务
db.Transaction(func(tx *core.Tx) error {
    // 2. 执行操作...

    // 3. 如果返回 error，自动回滚
    if err != nil {
        return err  // ROLLBACK
    }

    // 4. 如果返回 nil，自动提交
    return nil  // COMMIT
})
```

## 手动事务

### 开始事务

```go
tx, err := db.Begin()
if err != nil {
    panic(err)
}
```

### 提交事务

```go
tx, _ := db.Begin()

// 执行操作
_, err := tx.Model(&User{}).Insert(user)
if err != nil {
    tx.Rollback()
    panic(err)
}

// 提交事务
err = tx.Commit()
if err != nil {
    panic(err)
}
```

### 回滚事务

```go
tx, _ := db.Begin()

// 执行操作
_, err := tx.Model(&User{}).Insert(user)
if err != nil {
    // 发生错误，回滚
    tx.Rollback()
    panic(err)
}

// 提交
tx.Commit()
```

### 完整的手动事务示例

```go
func ManualTransaction(db *core.DB) error {
    // 开始事务
    tx, err := db.Begin()
    if err != nil {
        return fmt.Errorf("开始事务失败: %w", err)
    }

    // 使用 defer 确保资源释放
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
            panic(r)  // 重新抛出 panic
        }
    }()

    // 执行操作
    user := &User{Name: "Alice", Email: "alice@example.com"}
    id, err := tx.Model(user).Insert(user)
    if err != nil {
        tx.Rollback()
        return fmt.Errorf("插入用户失败: %w", err)
    }

    order := &Order{
        UserID: id,
        Amount: 100.0,
    }
    _, err = tx.Model(order).Insert(order)
    if err != nil {
        tx.Rollback()
        return fmt.Errorf("插入订单失败: %w", err)
    }

    // 提交事务
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("提交事务失败: %w", err)
    }

    return nil
}
```

## 实际应用场景

### 1. 银行转账

```go
func Transfer(db *core.DB, fromID, toID int64, amount float64) error {
    return db.Transaction(func(tx *core.Tx) error {
        // 检查转出账户余额
        var fromAccount Account
        err := tx.Model(&Account{}).
            Where("id = ?", fromID).
            First(&fromAccount)
        if err != nil {
            return fmt.Errorf("账户不存在: %w", err)
        }

        if fromAccount.Balance < amount {
            return fmt.Errorf("余额不足")
        }

        // 转出账户扣款
        _, err = tx.Model(&Account{}).
            Where("id = ?", fromID).
            Update(map[string]any{
                "balance": "balance - " + fmt.Sprintf("%.2f", amount),
            })
        if err != nil {
            return err
        }

        // 转入账户加款
        _, err = tx.Model(&Account{}).
            Where("id = ?", toID).
            Update(map[string]any{
                "balance": "balance + " + fmt.Sprintf("%.2f", amount),
            })
        if err != nil {
            return err
        }

        // 记录交易日志
        log := &TransactionLog{
            FromID: fromID,
            ToID:   toID,
            Amount: amount,
        }
        _, err = tx.Model(log).Insert(log)
        if err != nil {
            return err
        }

        return nil
    })
}
```

### 2. 创建订单

```go
func CreateOrder(db *core.DB, userID int64, items []OrderItem) (int64, error) {
    var orderID int64

    err := db.Transaction(func(tx *core.Tx) error {
        // 1. 创建订单
        order := &Order{
            UserID: userID,
            Status: "pending",
        }
        id, err := tx.Model(order).Insert(order)
        if err != nil {
            return err
        }
        orderID = id

        // 2. 创建订单项
        for _, item := range items {
            item.OrderID = orderID
            _, err := tx.Model(&item).Insert(item)
            if err != nil {
                return err
            }

            // 3. 扣减库存
            _, err = tx.Model(&Product{}).
                Where("id = ?", item.ProductID).
                Update(map[string]any{
                    "stock": "stock - " + fmt.Sprintf("%d", item.Quantity),
                })
            if err != nil {
                return err
            }
        }

        return nil
    })

    if err != nil {
        return 0, fmt.Errorf("创建订单失败: %w", err)
    }

    return orderID, nil
}
```

### 3. 注册用户

```go
func RegisterUser(db *core.DB, username, email, password string) error {
    return db.Transaction(func(tx *core.Tx) error {
        // 1. 检查用户名和邮箱是否已存在
        count, err := tx.Model(&User{}).
            Where("username = ? OR email = ?", username, email).
            Count()
        if err != nil {
            return err
        }
        if count > 0 {
            return fmt.Errorf("用户名或邮箱已存在")
        }

        // 2. 创建用户
        hashedPassword, err := hashPassword(password)
        if err != nil {
            return err
        }

        user := &User{
            Username: username,
            Email:    email,
            Password: hashedPassword,
            Status:   "active",
        }
        id, err := tx.Model(user).Insert(user)
        if err != nil {
            return err
        }

        // 3. 创建用户配置
        config := &UserConfig{
            UserID: id,
            Theme:  "light",
        }
        _, err = tx.Model(config).Insert(config)
        if err != nil {
            return err
        }

        // 4. 创建欢迎消息
        welcomeMsg := &Message{
            UserID: id,
            Title:  "欢迎",
            Content: "欢迎加入我们！",
        }
        _, err = tx.Model(welcomeMsg).Insert(welcomeMsg)
        if err != nil {
            return err
        }

        return nil
    })
}
```

### 4. 级联删除

```go
func DeleteUser(db *core.DB, userID int64) error {
    return db.Transaction(func(tx *core.Tx) error {
        // 1. 软删除用户的订单
        _, err := tx.Model(&Order{}).
            Where("user_id = ?", userID).
            Update(map[string]any{
                "deleted_at": time.Now(),
            })
        if err != nil {
            return err
        }

        // 2. 删除用户的评论
        _, err = tx.Model(&Comment{}).
            Where("user_id = ?", userID).
            Delete()
        if err != nil {
            return err
        }

        // 3. 删除用户配置
        _, err = tx.Model(&UserConfig{}).
            Where("user_id = ?", userID).
            Delete()
        if err != nil {
            return err
        }

        // 4. 删除用户
        _, err = tx.Model(&User{}).
            Where("id = ?", userID).
            Delete()
        if err != nil {
            return err
        }

        return nil
    })
}
```

## 嵌套事务

jorm 支持嵌套事务，内部事务失败会导致外部事务回滚：

```go
func OuterTransaction(db *core.DB) error {
    return db.Transaction(func(tx *core.Tx) error {
        // 外部事务操作
        user := &User{Name: "Alice"}
        id, err := tx.Model(user).Insert(user)
        if err != nil {
            return err
        }

        // 内部事务
        err = tx.Transaction(func(nestedTx *core.Tx) error {
            // 内部事务操作
            order := &Order{UserID: id, Amount: 100.0}
            _, err := nestedTx.Model(order).Insert(order)
            if err != nil {
                return err  // 内部事务失败，外部事务也会回滚
            }

            return nil
        })

        if err != nil {
            return err
        }

        return nil
    })
}
```

## 只读事务

### 设置只读事务

```go
err := db.Transaction(func(tx *core.Tx) error {
    // 执行只读操作
    var users []User
    err := tx.Model(&User{}).Find(&users)
    if err != nil {
        return err
    }

    // 不能执行写操作
    // _, err := tx.Model(&User{}).Insert(user)  // 会失败

    return nil
})
```

## 事务隔离级别

### 设置隔离级别

```go
// MySQL
err := db.Transaction(func(tx *core.Tx) error {
    // 设置隔离级别
    _, err := tx.Exec("SET TRANSACTION ISOLATION LEVEL READ COMMITTED")
    if err != nil {
        return err
    }

    // 执行操作
    var users []User
    err = tx.Model(&User{}).Find(&users)
    if err != nil {
        return err
    }

    return nil
})
```

### 常见隔离级别

- `READ UNCOMMITTED` - 读未提交
- `READ COMMITTED` - 读已提交（推荐）
- `REPEATABLE READ` - 可重复读（MySQL 默认）
- `SERIALIZABLE` - 串行化

## 错误处理

### 处理事务错误

```go
err := db.Transaction(func(tx *core.Tx) error {
    // 执行操作
    _, err := tx.Model(&User{}).Insert(user)
    if err != nil {
        return err  // 返回错误，自动回滚
    }

    return nil
})

if err != nil {
    // 事务失败
    fmt.Printf("事务失败: %v\n", err)
}
```

### 处理特定错误

```go
err := db.Transaction(func(tx *core.Tx) error {
    _, err := tx.Model(&User{}).Insert(user)
    if err != nil {
        if errors.Is(err, core.ErrDuplicateKey) {
            return fmt.Errorf("用户已存在")
        }
        return err
    }

    return nil
})
```

## 最佳实践

### 1. 使用函数式事务

```go
// 推荐：使用函数式事务
err := db.Transaction(func(tx *core.Tx) error {
    // 操作
    return nil
})

// 不推荐：使用手动事务
tx, _ := db.Begin()
// 操作
tx.Commit()
```

### 2. 保持事务简短

```go
// 推荐：只包含必要的数据库操作
err := db.Transaction(func(tx *core.Tx) error {
    tx.Model(&User{}).Insert(user)
    tx.Model(&Order{}).Insert(order)
    return nil
})

// 不推荐：在事务中执行耗时操作
err := db.Transaction(func(tx *core.Tx) error {
    tx.Model(&User{}).Insert(user)

    // 发送邮件（耗时操作）
    sendEmail(user.Email, "欢迎")

    tx.Model(&Order{}).Insert(order)
    return nil
})
```

### 3. 始终检查错误

```go
// 推荐
err := db.Transaction(func(tx *core.Tx) error {
    _, err := tx.Model(&User{}).Insert(user)
    if err != nil {
        return err
    }
    return nil
})

// 不推荐
db.Transaction(func(tx *core.Tx) error {
    tx.Model(&User{}).Insert(user)  // 忽略错误
    return nil
})
```

### 4. 避免在事务中调用外部服务

```go
// 推荐：先调用外部服务，再执行事务
orderID := createOrderID()

err := db.Transaction(func(tx *core.Tx) error {
    // 使用预先生成的 orderID
    tx.Model(&Order{}).Insert(&Order{ID: orderID})
    return nil
})

// 不推荐：在事务中调用外部服务
err := db.Transaction(func(tx *core.Tx) error {
    // 在事务中调用外部 API（慢且不可靠）
    orderID := callExternalAPI()
    tx.Model(&Order{}).Insert(&Order{ID: orderID})
    return nil
})
```

## 常见问题

### Q: 什么时候需要使用事务？

A: 当需要保证多个操作的原子性时：

- 银行转账
- 创建订单并扣减库存
- 注册用户并创建相关数据
- 级联删除

### Q: 函数式事务和手动事务有什么区别？

A:
- **函数式事务**（推荐）：自动提交/回滚，代码更简洁
- **手动事务**：需要手动调用 Commit/Rollback，更灵活

### Q: 事务会嵌套吗？

A: jorm 支持嵌套事务，但建议避免使用嵌套事务，会增加复杂度。

### Q: 如何在事务中回滚？

A: 在函数式事务中返回 error 即可回滚：

```go
err := db.Transaction(func(tx *core.Tx) error {
    if someCondition {
        return errors.New("出错了")  // 自动回滚
    }
    return nil  // 自动提交
})
```

### Q: 事务超时怎么办？

A: 使用 Context 设置超时：

```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

err := db.TransactionWithContext(ctx, func(tx *core.Tx) error {
    // 操作
    return nil
})
```

## 下一步

- [钩子函数](./09-钩子函数.md) - 学习钩子函数
- [关联关系](./10-关联关系.md) - 学习关联查询
- [性能优化](./17-性能优化.md) - 学习优化事务性能
