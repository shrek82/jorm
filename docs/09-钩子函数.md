# 钩子函数

本指南详细介绍 jorm 的钩子函数功能，可以在数据库操作前后执行自定义逻辑。

## 钩子函数概述

jorm 支持以下钩子函数：

- `BeforeInsert` - 插入前执行
- `AfterInsert` - 插入后执行
- `BeforeUpdate` - 更新前执行
- `AfterUpdate` - 更新后执行
- `BeforeDelete` - 删除前执行
- `AfterDelete` - 删除后执行
- `AfterFind` - 查询后执行

## 基本用法

### 定义钩子函数

```go
type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string    `jorm:"size:100 notnull"`
    Email     string    `jorm:"size:100 unique"`
    Age       int
    CreatedAt time.Time `jorm:"auto_time"`
    UpdatedAt time.Time `jorm:"auto_update"`
}

// BeforeInsert 插入前钩子
func (u *User) BeforeInsert() error {
    if u.Name == "" {
        return errors.New("name cannot be empty")
    }
    if u.Age < 0 {
        return errors.New("age cannot be negative")
    }
    return nil
}

// AfterInsert 插入后钩子
func (u *User) AfterInsert(id int64) error {
    u.ID = id
    fmt.Printf("User %s inserted with ID: %d\n", u.Name, id)
    return nil
}

// BeforeUpdate 更新前钩子
func (u *User) BeforeUpdate() error {
    if u.Age < 0 {
        return errors.New("age cannot be negative")
    }
    return nil
}

// AfterUpdate 更新后钩子
func (u *User) AfterUpdate() error {
    fmt.Printf("User %s updated\n", u.Name)
    return nil
}

// AfterFind 查询后钩子
func (u *User) AfterFind() error {
    // 数据转换或其他处理
    return nil
}
```

## 插入钩子

### BeforeInsert - 插入前

```go
type User struct {
    ID       int64  `jorm:"pk;auto"`
    Name     string `jorm:"size:100 notnull"`
    Password string `jorm:"size:255 notnull"`
    CreatedAt time.Time `jorm:"auto_time"`
}

func (u *User) BeforeInsert() error {
    // 验证数据
    if u.Name == "" {
        return errors.New("name is required")
    }
    if len(u.Password) < 6 {
        return errors.New("password too short")
    }

    // 密码加密
    u.Password = hashPassword(u.Password)

    return nil
}

// 使用
user := &User{
    Name:     "Alice",
    Password: "plainpassword",  // 会被加密
}
db.Model(user).Insert(user)
```

### AfterInsert - 插入后

```go
type User struct {
    ID        int64  `jorm:"pk;auto"`
    Name      string
    CreatedAt time.Time `jorm:"auto_time"`
}

func (u *User) AfterInsert(id int64) error {
    // 更新结构体中的 ID
    u.ID = id

    // 发送欢迎邮件
    go sendWelcomeEmail(u.Name, u.Email)

    // 记录日志
    log.Printf("New user created: %d\n", id)

    return nil
}

// 使用
user := &User{Name: "Alice"}
id, _ := db.Model(user).Insert(user)
fmt.Printf("User ID in struct: %d\n", user.ID)  // 已更新
```

## 更新钩子

### BeforeUpdate - 更新前

```go
type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string
    Email     string
    UpdatedAt time.Time `jorm:"auto_update"`
}

func (u *User) BeforeUpdate() error {
    // 验证邮箱格式
    if u.Email != "" && !isValidEmail(u.Email) {
        return errors.New("invalid email format")
    }

    // 禁止修改某些字段
    if u.ID == 1 {
        return errors.New("cannot modify admin user")
    }

    return nil
}

// 使用
user := &User{ID: 2, Email: "newemail@example.com"}
db.Model(&User{}).Where("id = ?", user.ID).Update(user)
```

### AfterUpdate - 更新后

```go
type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string
    Status    string
    UpdatedAt time.Time `jorm:"auto_update"`
}

func (u *User) AfterUpdate() error {
    // 状态变更通知
    if u.Status == "active" {
        go sendActivationNotification(u.Name, u.Email)
    }

    // 更新缓存
    updateUserCache(u.ID, u)

    return nil
}

// 使用
db.Model(&User{}).Where("id = ?", 1).
    Update(map[string]any{"status": "active"})
```

## 删除钩子

### BeforeDelete - 删除前

```go
type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string
    IsAdmin   bool      `jorm:"type:boolean"`
}

func (u *User) BeforeDelete() error {
    // 禁止删除管理员
    if u.IsAdmin {
        return errors.New("cannot delete admin user")
    }

    // 检查是否有未完成的订单
    if hasUncompletedOrders(u.ID) {
        return errors.New("user has uncompleted orders")
    }

    return nil
}

// 使用
db.Model(&User{}).Where("id = ?", 1).Delete()
```

### AfterDelete - 删除后

```go
type User struct {
    ID   int64 `jorm:"pk;auto"`
    Name string
}

func (u *User) AfterDelete() error {
    // 删除关联数据
    deleteUserData(u.ID)

    // 清除缓存
    clearUserCache(u.ID)

    // 记录日志
    log.Printf("User deleted: %d\n", u.ID)

    return nil
}

// 使用
db.Model(&User{}).Where("id = ?", 1).Delete()
```

## 查询钩子

### AfterFind - 查询后

```go
type User struct {
    ID       int64  `jorm:"pk;auto"`
    Name     string
    Age      int
    AgeText  string `jorm:"-"`  // 不映射到数据库
}

func (u *User) AfterFind() error {
    // 数据转换
    if u.Age < 18 {
        u.AgeText = "未成年"
    } else if u.Age < 60 {
        u.AgeText = "成年"
    } else {
        u.AgeText = "老年"
    }

    return nil
}

// 使用
var users []User
db.Model(&User{}).Find(&users)
for _, user := range users {
    fmt.Printf("%s: %s\n", user.Name, user.AgeText)
}
```

## 完整示例

### 用户模型

```go
type User struct {
    ID        int64      `jorm:"pk;auto column:id"`
    Name      string     `jorm:"size:100 notnull column:name"`
    Email     string     `jorm:"size:100 unique column:email"`
    Password  string     `jorm:"size:255 column:password"`
    Status    string     `jorm:"size:20 default:'active' column:status"`
    IsAdmin   bool       `jorm:"type:boolean default:false column:is_admin"`
    CreatedAt time.Time  `jorm:"auto_time column:created_at"`
    UpdatedAt time.Time  `jorm:"auto_update column:updated_at"`
}

// BeforeInsert 插入前
func (u *User) BeforeInsert() error {
    // 验证必填字段
    if u.Name == "" {
        return errors.New("name is required")
    }
    if u.Email == "" {
        return errors.New("email is required")
    }
    if u.Password == "" {
        return errors.New("password is required")
    }

    // 验证邮箱格式
    if !isValidEmail(u.Email) {
        return errors.New("invalid email format")
    }

    // 密码加密
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return fmt.Errorf("password encryption failed: %w", err)
    }
    u.Password = string(hashedPassword)

    // 设置默认状态
    if u.Status == "" {
        u.Status = "active"
    }

    return nil
}

// AfterInsert 插入后
func (u *User) AfterInsert(id int64) error {
    // 更新结构体 ID
    u.ID = id

    // 创建用户配置
    go func() {
        config := &UserConfig{
            UserID: id,
            Theme:  "light",
        }
        db.Model(config).Insert(config)
    }()

    // 发送欢迎邮件
    go func() {
        sendWelcomeEmail(u.Email, u.Name)
    }()

    // 记录日志
    log.Printf("New user created: ID=%d, Name=%s, Email=%s\n", id, u.Name, u.Email)

    return nil
}

// BeforeUpdate 更新前
func (u *User) BeforeUpdate() error {
    // 验证邮箱格式
    if u.Email != "" && !isValidEmail(u.Email) {
        return errors.New("invalid email format")
    }

    // 禁止修改管理员邮箱
    if u.IsAdmin && u.Email != "" {
        var oldUser User
        if err := db.Model(&User{}).Where("id = ?", u.ID).First(&oldUser); err == nil {
            if oldUser.IsAdmin && oldUser.Email != u.Email {
                return errors.New("cannot change admin email")
            }
        }
    }

    return nil
}

// AfterUpdate 更新后
func (u *User) AfterUpdate() error {
    // 状态变更通知
    if u.Status == "active" {
        go sendActivationNotification(u.Email)
    }

    // 更新缓存
    updateUserCache(u.ID, u)

    return nil
}

// BeforeDelete 删除前
func (u *User) BeforeDelete() error {
    // 禁止删除管理员
    if u.IsAdmin {
        return errors.New("cannot delete admin user")
    }

    // 检查是否有未完成的订单
    count, _ := db.Model(&Order{}).
        Where("user_id = ? AND status IN ?", u.ID, []string{"pending", "processing"}).
        Count()
    if count > 0 {
        return errors.New("cannot delete user with active orders")
    }

    return nil
}

// AfterDelete 删除后
func (u *User) AfterDelete() error {
    // 清除缓存
    clearUserCache(u.ID)

    // 记录日志
    log.Printf("User deleted: ID=%d, Name=%s\n", u.ID, u.Name)

    return nil
}
```

### 产品模型

```go
type Product struct {
    ID        int64     `jorm:"pk;auto column:id"`
    Name      string    `jorm:"size:200 notnull column:name"`
    Price     float64   `jorm:"type:decimal(10,2) notnull column:price"`
    CostPrice float64   `jorm:"type:decimal(10,2) column:cost_price"`
    Stock     int       `jorm:"type:int default:0 column:stock"`
    Status    string    `jorm:"size:20 default:'draft' column:status"`
    CreatedAt time.Time `jorm:"auto_time column:created_at"`
    UpdatedAt time.Time `jorm:"auto_update column:updated_at"`

    PriceText string `jorm:"-"`  // 不映射到数据库
}

// BeforeInsert 插入前
func (p *Product) BeforeInsert() error {
    // 验证价格
    if p.Price <= 0 {
        return errors.New("price must be positive")
    }
    if p.CostPrice > p.Price {
        return errors.New("cost price cannot be greater than selling price")
    }

    // 验证库存
    if p.Stock < 0 {
        return errors.New("stock cannot be negative")
    }

    // 设置默认状态
    if p.Status == "" {
        p.Status = "draft"
    }

    return nil
}

// AfterInsert 插入后
func (p *Product) AfterInsert(id int64) error {
    p.ID = id

    // 记录价格历史
    go func() {
        history := &PriceHistory{
            ProductID: id,
            Price:     p.Price,
            CostPrice: p.CostPrice,
        }
        db.Model(history).Insert(history)
    }()

    return nil
}

// BeforeUpdate 更新前
func (p *Product) BeforeUpdate() error {
    // 价格变更时记录旧价格
    if p.Price != p.PriceText {
        // 这里可以记录价格变更历史
    }

    // 验证价格
    if p.Price <= 0 {
        return errors.New("price must be positive")
    }

    return nil
}

// AfterFind 查询后
func (p *Product) AfterFind() error {
    // 格式化价格显示
    p.PriceText = fmt.Sprintf("¥%.2f", p.Price)

    return nil
}
```

## 钩子函数中的错误处理

### 错误会中止操作

```go
type User struct {
    ID   int64  `jorm:"pk;auto"`
    Name string
}

func (u *User) BeforeInsert() error {
    if u.Name == "" {
        return errors.New("name is required")  // 插入会被中止
    }
    return nil
}

// 使用
user := &User{Name: ""}  // 空名称
_, err := db.Model(user).Insert(user)
if err != nil {
    fmt.Println(err)  // name is required
}
```

### 事务中的钩子函数

```go
err := db.Transaction(func(tx *core.Tx) error {
    user := &User{Name: "Alice"}
    _, err := tx.Model(user).Insert(user)
    if err != nil {
        return err  // 如果钩子函数返回错误，事务会回滚
    }

    return nil
})
```

## 最佳实践

### 1. 钩子函数保持简单

```go
// 推荐：钩子函数简单明了
func (u *User) BeforeInsert() error {
    if u.Name == "" {
        return errors.New("name is required")
    }
    return nil
}

// 不推荐：钩子函数过于复杂
func (u *User) BeforeInsert() error {
    if u.Name == "" {
        return errors.New("name is required")
    }
    // 大量的业务逻辑...
    // 复杂的外部调用...
    // 应该移到业务层
    return nil
}
```

### 2. 在钩子函数中使用 goroutine 时要小心

```go
// 推荐：简单日志
func (u *User) AfterInsert(id int64) error {
    log.Printf("User created: %d\n", id)
    return nil
}

// 小心：异步操作可能失败
func (u *User) AfterInsert(id int64) error {
    go sendEmail(u.Email)  // 如果失败，无法回滚
    return nil
}
```

### 3. 不要在钩子函数中修改其他表

```go
// 推荐：在业务层处理关联操作
func CreateUserWithOrder(db *core.DB, user *User, order *Order) error {
    return db.Transaction(func(tx *core.Tx) error {
        id, _ := tx.Model(user).Insert(user)
        order.UserID = id
        tx.Model(order).Insert(order)
        return nil
    })
}

// 不推荐：在钩子函数中修改其他表
func (u *User) AfterInsert(id int64) error {
    order := &Order{UserID: id}
    db.Model(order).Insert(order)  // 不在事务中，容易出错
    return nil
}
```

### 4. 使用钩子函数进行数据验证

```go
// 推荐：在 BeforeInsert/BeforeUpdate 中验证
func (u *User) BeforeInsert() error {
    if u.Age < 18 {
        return errors.New("must be 18 or older")
    }
    return nil
}

// 不推荐：依赖外部验证
user := &User{Age: 15}
if user.Age >= 18 {
    db.Model(user).Insert(user)
}
```

## 常见问题

### Q: 钩子函数返回错误会怎样？

A: 操作会被中止，如果是在事务中，事务会回滚。

### Q: 可以在钩子函数中修改数据吗？

A: 可以，这是钩子函数的常见用途：

```go
func (u *User) BeforeInsert() error {
    u.Password = hashPassword(u.Password)
    return nil
}
```

### Q: AfterFind 钩子会在什么时候调用？

A: 每次查询数据后都会调用，包括 First、Find 等。

### Q: 钩子函数会影响性能吗？

A: 会，但影响很小。如果钩子函数中有耗时操作，建议使用 goroutine。

## 下一步

- [数据验证](./11-数据验证.md) - 学习数据验证
- [关联关系](./10-关联关系.md) - 学习关联查询
- [最佳实践](./18-最佳实践.md) - 了解更多最佳实践
