# 数据验证

本指南详细介绍 jorm 的数据验证功能，可以在插入或更新前验证数据。

## 基本验证

### 定义验证规则

```go
import "github.com/shrek82/jorm"

type User struct {
    ID    int64  `jorm:"pk auto"`
    Name  string `jorm:"size:100"`
    Email string `jorm:"size:100"`
    Age   int
}

func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Name": {
            jorm.Required.Msg("Name is required"),
            jorm.MinLen(2).Msg("Name too short"),
            jorm.MaxLen(50).Msg("Name too long"),
        },
        "Email": {
            jorm.Required.Msg("Email is required"),
            jorm.Email.Msg("Invalid email format"),
        },
        "Age": {
            jorm.Required.Msg("Age is required"),
            jorm.Range(18, 100).Msg("Must be between 18 and 100"),
        },
    }.Validate
}
```

### 使用验证

```go
// 创建用户
user := &User{
    Name:  "Alice",
    Email: "alice@example.com",
    Age:   25,
}

// 带验证的插入
id, err := db.Model(user).InsertWithValidator(user, user.GetValidator())
if err != nil {
    if validationErrs, ok := err.(jorm.ValidationErrors); ok {
        for field, messages := range validationErrs {
            fmt.Printf("%s: %v\n", field, messages)
        }
        return
    }
    panic(err)
}

fmt.Printf("用户创建成功，ID: %d\n", id)
```

## 内置验证规则

### 必填验证

```go
jorm.Required.Msg("该字段必填")
```

### 长度验证

```go
jorm.MinLen(2)       // 最小长度
jorm.MaxLen(100)     // 最大长度
jorm.Len(10)         // 固定长度
```

### 范围验证

```go
jorm.Range(18, 100)  // 数值范围
jorm.Min(0)          // 最小值
jorm.Max(100)        // 最大值
```

### 格式验证

```go
jorm.Email      // 邮箱格式
jorm.Mobile     // 手机号格式
jorm.URL        // URL格式
jorm.IP         // IP地址格式
jorm.UUID       // UUID格式
jorm.JSON       // JSON格式
jorm.Numeric    // 纯数字
jorm.Alpha      // 纯字母
jorm.AlphaNumeric  // 字母数字
```

### 正则表达式

```go
jorm.Regexp(`^[a-z]+$`)  // 自定义正则
```

### 包含/排除

```go
jorm.In("active", "pending", "completed")  // 枚举值
jorm.Contains("example")                      // 包含子串
jorm.Excludes("admin")                       // 排除子串
jorm.NoHTML                                  // 不允许HTML标签
```

### 日期时间

```go
jorm.Datetime("2006-01-02")      // 日期格式
jorm.Datetime("2006-01-02 15:04:05")  // 日期时间格式
```

## 完整示例

### 用户验证

```go
type User struct {
    ID       int64  `jorm:"pk auto"`
    Username string `jorm:"size:50"`
    Email    string `jorm:"size:100"`
    Password string `jorm:"size:255"`
    Age      int
    Phone    string `jorm:"size:20"`
    Website  string `jorm:"size:200"`
}

func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Username": {
            jorm.Required.Msg("用户名必填"),
            jorm.MinLen(3).Msg("用户名至少3个字符"),
            jorm.MaxLen(20).Msg("用户名最多20个字符"),
            jorm.AlphaNumeric.Msg("用户名只能包含字母和数字"),
        },
        "Email": {
            jorm.Required.Msg("邮箱必填"),
            jorm.Email.Msg("邮箱格式不正确"),
        },
        "Password": {
            jorm.Required.Msg("密码必填"),
            jorm.MinLen(6).Msg("密码至少6个字符"),
            jorm.MaxLen(100).Msg("密码最多100个字符"),
        },
        "Age": {
            jorm.Required.Msg("年龄必填"),
            jorm.Range(18, 120).Msg("年龄必须在18到120之间"),
        },
        "Phone": {
            jorm.Mobile.Msg("手机号格式不正确"),
        },
        "Website": {
            jorm.URL.Msg("URL格式不正确"),
        },
    }.Validate
}

// 使用
user := &User{
    Username: "alice123",
    Email:    "alice@example.com",
    Password: "password123",
    Age:      25,
    Phone:    "13800138000",
    Website:  "https://example.com",
}

id, err := db.Model(user).InsertWithValidator(user, user.GetValidator())
if err != nil {
    fmt.Printf("验证失败: %v\n", err)
    return
}

fmt.Printf("用户创建成功，ID: %d\n", id)
```

### 产品验证

```go
type Product struct {
    ID          int64   `jorm:"pk auto"`
    Name        string  `jorm:"size:200"`
    Description string  `jorm:"type:text"`
    Price       float64
    Stock       int
    Status      string
}

func (p *Product) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Name": {
            jorm.Required.Msg("产品名称必填"),
            jorm.MinLen(2).Msg("产品名称至少2个字符"),
            jorm.MaxLen(200).Msg("产品名称最多200个字符"),
        },
        "Price": {
            jorm.Required.Msg("价格必填"),
            jorm.Min(0.01).Msg("价格必须大于0"),
        },
        "Stock": {
            jorm.Required.Msg("库存必填"),
            jorm.Min(0).Msg("库存不能为负数"),
        },
        "Status": {
            jorm.Required.Msg("状态必填"),
            jorm.In("draft", "published", "out_of_stock").Msg("状态无效"),
        },
    }.Validate
}

// 使用
product := &Product{
    Name:    "苹果手机",
    Price:   5999.00,
    Stock:   100,
    Status:  "published",
}

id, err := db.Model(product).InsertWithValidator(product, product.GetValidator())
if err != nil {
    fmt.Printf("验证失败: %v\n", err)
    return
}

fmt.Printf("产品创建成功，ID: %d\n", id)
```

## 更新时验证

```go
// 带验证的更新
user := &User{
    ID:    1,
    Name:  "Bob",
    Email: "bob@example.com",
    Age:   30,
}

affected, err := db.Model(&User{}).
    Where("id = ?", user.ID).
    UpdateWithValidator(user, user.GetValidator())
if err != nil {
    if validationErrs, ok := err.(jorm.ValidationErrors); ok {
        fmt.Printf("验证失败: %v\n", validationErrs)
        return
    }
    panic(err)
}

fmt.Printf("更新了 %d 条记录\n", affected)
```

## 自定义验证规则

### 使用 Regexp

```go
type User struct {
    ID       int64  `jorm:"pk auto"`
    Username string
}

func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Username": {
            jorm.Required,
            jorm.Regexp(`^[a-z][a-z0-9_]*$`).Msg("用户名必须以小写字母开头，只能包含小写字母、数字和下划线"),
        },
    }.Validate
}
```

### 自定义验证函数

```go
type User struct {
    ID          int64  `jorm:"pk auto"`
    Password    string `jorm:"size:255"`
    ConfirmPassword string `jorm:"-"`
}

func (u *User) CustomValidator() jorm.Validator {
    return func(v any) error {
        user := v.(*User)
        if user.Password != user.ConfirmPassword {
            return fmt.Errorf("两次输入的密码不一致")
        }
        return nil
    }
}

// 使用多个验证器
id, err := db.Model(user).InsertWithValidator(user,
    jorm.Rules{
        "Password": {
            jorm.Required,
            jorm.MinLen(6),
        },
    }.Validate,
    user.CustomValidator(),
)
```

## 验证错误处理

### 获取详细错误信息

```go
id, err := db.Model(user).InsertWithValidator(user, user.GetValidator())
if err != nil {
    if validationErrs, ok := err.(jorm.ValidationErrors); ok {
        for field, messages := range validationErrs {
            fmt.Printf("%s:\n", field)
            for _, msg := range messages {
                fmt.Printf("  - %s\n", msg)
            }
        }
        return
    }
    panic(err)
}
```

### 转换为 JSON 响应

```go
func handleValidationErrors(err error) map[string][]string {
    validationErrs, ok := err.(jorm.ValidationErrors)
    if !ok {
        return nil
    }

    result := make(map[string][]string)
    for field, messages := range validationErrs {
        result[field] = messages
    }

    return result
}

// API 返回
if err != nil {
    c.JSON(400, gin.H{
        "error": "validation failed",
        "details": handleValidationErrors(err),
    })
    return
}
```

## 复杂验证场景

### 条件验证

```go
type User struct {
    ID     int64  `jorm:"pk auto"`
    Type   string `jorm:"size:20"`
    Email  string `jorm:"size:100"`
    Phone  string `jorm:"size:20"`
}

func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Type": {
            jorm.Required,
            jorm.In("personal", "business").Msg("类型无效"),
        },
        "Email": {
            // 个人用户必填邮箱
            jorm.Required.If(u.Type == "personal").Msg("个人用户必须填写邮箱"),
            jorm.Email,
        },
        "Phone": {
            // 企业用户必填电话
            jorm.Required.If(u.Type == "business").Msg("企业用户必须填写电话"),
            jorm.Mobile,
        },
    }.Validate
}
```

### 组合验证

```go
type Order struct {
    ID       int64     `jorm:"pk auto"`
    UserID   int64     `jorm:"fk:User.ID"`
    Amount   float64
    Quantity int
    Date     time.Time `jorm:"auto_time"`
}

func (o *Order) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Amount": {
            jorm.Required,
            jorm.Min(0.01).Msg("金额必须大于0"),
        },
        "Quantity": {
            jorm.Required,
            jorm.Min(1).Msg("数量至少为1"),
            jorm.Max(1000).Msg("数量不能超过1000"),
        },
    }.Validate
}

func (o *Order) GetBusinessValidator() jorm.Validator {
    return func(v any) error {
        // 基础验证
        if err := o.GetValidator()(v); err != nil {
            return err
        }

        order := v.(*Order)

        // 业务验证：订单总金额不能超过用户余额
        var user User
        if err := db.Model(&User{}).Where("id = ?", order.UserID).First(&user); err != nil {
            return fmt.Errorf("用户不存在")
        }

        if order.Amount > user.Balance {
            return fmt.Errorf("余额不足")
        }

        return nil
    }
}
```

## 最佳实践

### 1. 为每个模型定义验证器

```go
// 推荐
type User struct {
    ID   int64  `jorm:"pk auto"`
    Name string
}
func (u *User) GetValidator() jorm.Validator { ... }

// 不推荐：不定义验证器
type User struct {
    ID   int64  `jorm:"pk auto"`
    Name string
}
```

### 2. 提供友好的错误消息

```go
// 推荐
jorm.Required.Msg("用户名不能为空")
jorm.MinLen(2).Msg("用户名至少2个字符")

// 不推荐
jorm.Required
jorm.MinLen(2)
```

### 3. 在插入和更新时都验证

```go
// 推荐
id, _ := db.Model(user).InsertWithValidator(user, user.GetValidator())
affected, _ := db.Model(&User{}).
    Where("id = ?", user.ID).
    UpdateWithValidator(user, user.GetValidator())

// 不推荐：只在插入时验证
id, _ := db.Model(user).InsertWithValidator(user, user.GetValidator())
affected, _ := db.Model(&User{}).Where("id = ?", user.ID).Update(user)
```

### 4. 与钩子函数配合使用

验证器和钩子函数可以配合使用：

- **验证器**：在插入/更新前验证数据格式和业务规则
- **钩子函数**：在验证通过后，对数据进行处理（如加密、计算等）

**示例：密码验证和加密**

```go
type User struct {
    ID       int64  `jorm:"pk auto"`
    Username string
    Password string `jorm:"size:255"`
}

// 验证器：检查密码格式
func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Password": {
            jorm.Required.Msg("密码必填"),
            jorm.MinLen(6).Msg("密码至少6个字符"),
        },
    }.Validate
}

// 钩子函数：加密密码（详见 [钩子函数](./09-钩子函数.md)）
func (u *User) BeforeInsert() error {
    u.Password = hashPassword(u.Password)
    return nil
}

// 使用：验证通过后自动加密
id, err := db.Model(user).InsertWithValidator(user, user.GetValidator())
```

**执行顺序**：
1. 先执行验证器 → 验证失败则中止
2. 验证通过后执行钩子函数
3. 最后执行插入/更新操作

> 💡 详细了解钩子函数，请阅读 [钩子函数](./09-钩子函数.md) 章节

## 下一步

- [钩子函数](./09-钩子函数.md) - 学习钩子函数
- [错误处理](./16-错误处理.md) - 学习错误处理
- [最佳实践](./18-最佳实践.md) - 了解更多最佳实践
