# 最佳实践

本指南总结了使用 jorm 时的最佳实践和常见模式。

## 代码组织

### 模型定义

```go
// models/user.go
package models

type User struct {
    ID        int64     `jorm:"pk;auto"`
    Name      string    `jorm:"size:100 notnull"`
    Email     string    `jorm:"size:100 unique"`
    CreatedAt time.Time `jorm:"auto_time"`
    UpdatedAt time.Time `jorm:"auto_update"`
}

func (u *User) TableName() string {
    return "users"
}
```

### 数据库访问层

```go
// repository/user_repository.go
package repository

import "github.com/shrek82/jorm/core"

type UserRepository struct {
    db *core.DB
}

func NewUserRepository(db *core.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) Create(user *models.User) (int64, error) {
    return r.db.Model(user).Insert(user)
}

func (r *UserRepository) GetByID(id int64) (*models.User, error) {
    var user models.User
    err := r.db.Model(&models.User{}).Where("id = ?", id).First(&user)
    if err != nil {
        return nil, err
    }
    return &user, nil
}
```

## 查询优化

### 只查询需要的字段

```go
// 推荐
db.Model(&User{}).
    Select("id", "name", "email").
    Find(&users)

// 不推荐
db.Model(&User{}).Find(&users)  // 查询所有字段
```

### 使用索引

```go
type User struct {
    Email string `jorm:"size:100 unique index"`
    Age   int    `jorm:"index"`
}

// 查询时使用索引字段
db.Model(&User{}).Where("email = ?", "user@example.com").First(&user)
```

### 分页查询

```go
// 推荐
page := 1
pageSize := 20
offset := (page - 1) * pageSize

db.Model(&User{}).
    Limit(pageSize).
    Offset(offset).
    Find(&users)
```

### 使用 Count 而不是 len

```go
// 推荐
count, err := db.Model(&User{}).Where("status = ?", "active").Count()
if err != nil {
    return err
}

// 不推荐
var users []User
err := db.Model(&User{}).Where("status = ?", "active").Find(&users)
count := len(users)
```

## 批量操作

### 批量插入

```go
// 推荐
users := []*User{{Name: "Alice"}, {Name: "Bob"}}
count, err := db.Model(&User{}).BatchInsert(users)

// 不推荐
for _, user := range users {
    db.Model(&User{}).Insert(user)
}
```

### 批量更新

```go
// 推荐
db.Model(&User{}).
    Where("status = ?", "pending").
    Update(map[string]any{"status": "active"})

// 不推荐
pendingUsers := getPendingUsers()
for _, user := range pendingUsers {
    db.Model(&User{}).Where("id = ?", user.ID).
        Update(map[string]any{"status": "active"})
}
```

## 事务使用

### 使用函数式事务

```go
// 推荐
err := db.Transaction(func(tx *core.Tx) error {
    // 操作
    return nil
})

// 不推荐：手动事务
tx, _ := db.Begin()
// 操作
tx.Commit()
```

### 保持事务简短

```go
// 推荐：只包含数据库操作
err := db.Transaction(func(tx *core.Tx) error {
    tx.Model(&User{}).Insert(user)
    tx.Model(&Order{}).Insert(order)
    return nil
})

// 不推荐：在事务中包含耗时操作
err := db.Transaction(func(tx *core.Tx) error {
    tx.Model(&User{}).Insert(user)
    sendEmail(user.Email)  // 耗时操作
    tx.Model(&Order{}).Insert(order)
    return nil
})
```

### 避免在事务中调用外部服务

```go
// 推荐
orderID := createOrderID()
err := db.Transaction(func(tx *core.Tx) error {
    tx.Model(&Order{}).Insert(&Order{ID: orderID})
    return nil
})

// 不推荐
err := db.Transaction(func(tx *core.Tx) error {
    orderID := callExternalAPI()  // 慢且不可靠
    tx.Model(&Order{}).Insert(&Order{ID: orderID})
    return nil
})
```

## 错误处理

### 始终检查错误

```go
// 推荐
id, err := db.Model(user).Insert(user)
if err != nil {
    return fmt.Errorf("创建用户失败: %w", err)
}

// 不推荐
id, _ := db.Model(user).Insert(user)
```

### 处理特定错误

```go
id, err := db.Model(user).Insert(user)
if err != nil {
    if errors.Is(err, core.ErrDuplicateKey) {
        return fmt.Errorf("用户已存在")
    }
    return err
}
```

### 使用事务处理相关操作

```go
// 推荐
err := db.Transaction(func(tx *core.Tx) error {
    tx.Model(&User{}).Insert(user)
    tx.Model(&Order{}).Insert(order)
    return nil
})

// 不推荐
tx.Model(&User{}).Insert(user)
tx.Model(&Order{}).Insert(order)
```

## 数据验证

### 在模型中定义验证器

```go
type User struct {
    ID   int64  `jorm:"pk;auto"`
    Name string
}

func (u *User) GetValidator() jorm.Validator {
    return jorm.Rules{
        "Name": {jorm.Required, jorm.MinLen(2)},
    }.Validate
}
```

### 在插入和更新时都验证

```go
id, err := db.Model(user).InsertWithValidator(user, user.GetValidator())
affected, err := db.Model(&User{}).
    Where("id = ?", user.ID).
    UpdateWithValidator(user, user.GetValidator())
```

## 性能优化

### 连接池配置

```go
// 开发环境
&core.Options{
    MaxOpenConns:    10,
    MaxIdleConns:    5,
    ConnMaxLifetime: time.Hour,
}

// 生产环境
&core.Options{
    MaxOpenConns:    100,
    MaxIdleConns:    20,
    ConnMaxLifetime: 30 * time.Minute,
}
```

### 使用预编译语句

jorm 会自动缓存 SQL，不需要手动处理。

### 合理使用索引

```go
// 在经常查询的字段上创建索引
type User struct {
    Email string `jorm:"size:100 unique index"`
    Age   int    `jorm:"index"`
    Status string `jorm:"size:20 index"`
}
```

## 安全

### 使用参数化查询

```go
// 推荐
db.Model(&User{}).Where("id = ?", userInput).Find(&users)

// 不推荐：SQL 注入风险
db.Model(&User{}).Where("id = " + userInput).Find(&users)
```

### 密码加密

```go
type User struct {
    Password string `jorm:"size:255"`
}

func (u *User) BeforeInsert() error {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.Password = string(hashedPassword)
    return nil
}
```

### 敏感数据处理

```go
// 不在日志中记录敏感信息
type User struct {
    Password string `jorm:"size:255"`
}

func (u *User) String() string {
    return fmt.Sprintf("User{ID: %d, Name: %s}", u.ID, u.Name)
}
```

## 测试

### 使用测试数据库

```go
func TestUserRepository(t *testing.T) {
    // 使用内存数据库
    db, err := core.Open("sqlite3", ":memory:", nil)
    if err != nil {
        t.Fatal(err)
    }
    defer db.Close()

    // 迁移表结构
    err = db.AutoMigrate(&User{})
    if err != nil {
        t.Fatal(err)
    }

    // 测试
    repo := NewUserRepository(db)
    user := &User{Name: "Test User"}
    id, err := repo.Create(user)
    if err != nil {
        t.Fatal(err)
    }

    if id == 0 {
        t.Error("Expected non-zero ID")
    }
}
```

### Mock 数据库

```go
type MockDB struct {
    core.DB
}

func (m *MockDB) Model(model any) *core.Query {
    // 返回 mock 查询
}
```

## 常见模式

### 软删除

```go
type BaseModel struct {
    DeletedAt *time.Time `jorm:"type:datetime"`
}

type User struct {
    BaseModel
    ID   int64  `jorm:"pk;auto"`
    Name string
}

// 查询未删除的记录
db.Model(&User{}).Where("deleted_at IS NULL").Find(&users)

// 软删除
now := time.Now()
db.Model(&User{}).Where("id = ?", 1).
    Update(map[string]any{"deleted_at": &now})
```

### 时间戳

```go
type BaseModel struct {
    ID        int64     `jorm:"pk;auto"`
    CreatedAt time.Time `jorm:"auto_time"`
    UpdatedAt time.Time `jorm:"auto_update"`
}

type User struct {
    BaseModel
    Name string
}
```

### 全局唯一 ID

```go
import "github.com/google/uuid"

type User struct {
    ID uuid.UUID `jorm:"pk type:char(36)"`
    Name string
}

func (u *User) BeforeInsert() error {
    if u.ID == uuid.Nil {
        u.ID = uuid.New()
    }
    return nil
}
```

## 监控和调试

### 记录慢查询

```go
type SlowQueryLogger struct {
    threshold time.Duration
}

func (l *SlowQueryLogger) Log(level logger.LogLevel, sql string, args ...any) {
    // 记录慢查询
}
```

### 监控连接池

```go
stats := db.Stats()
fmt.Printf("Open connections: %d\n", stats.OpenConnections)
fmt.Printf("Idle connections: %d\n", stats.Idle)
```

## 总结

1. **代码组织**：使用 Repository 模式，保持代码清晰
2. **查询优化**：只查询需要的字段，使用索引
3. **批量操作**：优先使用批量方法
4. **事务使用**：使用函数式事务，保持简短
5. **错误处理**：始终检查错误，处理特定错误
6. **数据验证**：定义验证器，在插入和更新时验证
7. **性能优化**：合理配置连接池，使用索引
8. **安全**：使用参数化查询，加密敏感数据
9. **测试**：使用测试数据库，编写单元测试
10. **监控**：记录慢查询，监控连接池

## 下一步

- [性能优化](./17-性能优化.md) - 深入了解性能优化
- [错误处理](./16-错误处理.md) - 学习错误处理技巧
- 返回 [目录](./00-目录.md)
