# 数据库连接

本指南详细介绍如何在 jorm 中连接和配置数据库，包括连接池设置、重试机制等。

## 基本连接

### MySQL

```go
import (
    "github.com/shrek82/jorm/core"
    _ "github.com/go-sql-driver/mysql"
)

db, err := core.Open("mysql", "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4", nil)
if err != nil {
    panic(err)
}
defer db.Close()
```

### PostgreSQL

```go
import (
    "github.com/shrek82/jorm/core"
    _ "github.com/lib/pq"
)

db, err := core.Open("postgres", "host=localhost port=5432 user=postgres dbname=app sslmode=disable", nil)
if err != nil {
    panic(err)
}
defer db.Close()
```

### SQLite

```go
import (
    "github.com/shrek82/jorm/core"
    _ "github.com/mattn/go-sqlite3"
)

db, err := core.Open("sqlite3", "./app.db", nil)
if err != nil {
    panic(err)
}
defer db.Close()
```

### Oracle

```go
import (
    "github.com/shrek82/jorm/core"
    _ "github.com/sijms/go-ora/v2"
)

db, err := core.Open("oracle", "oracle://user:password@localhost:1521/service_name", nil)
if err != nil {
    panic(err)
}
defer db.Close()
```

### SQL Server

```go
import (
    "github.com/shrek82/jorm/core"
    _ "github.com/microsoft/go-mssqldb"
)

db, err := core.Open("sqlserver", "server=localhost;user id=sa;password=yourPassword;database=master", nil)
if err != nil {
    panic(err)
}
defer db.Close()
```

## 连接选项

使用 `Options` 结构体配置数据库连接：

```go
import "time"

opts := &core.Options{
    MaxOpenConns:    100,              // 最大打开连接数
    MaxIdleConns:    10,               // 最大空闲连接数
    ConnMaxLifetime: time.Hour,        // 连接最大生命周期
    MaxRetries:      3,                // 连接失败重试次数
    RetryDelay:      time.Second,       // 重试延迟
}

db, err := core.Open("mysql", "user:password@/dbname", opts)
```

### 选项详解

#### MaxOpenConns

最大打开连接数。设置为 0 表示不限制。

```go
&core.Options{
    MaxOpenConns: 100,  // 最多同时打开100个连接
}
```

**建议值：**
- 开发环境：10
- 生产环境：根据数据库服务器配置和并发需求，通常 50-200

#### MaxIdleConns

最大空闲连接数。保持一定数量的空闲连接可以提高性能。

```go
&core.Options{
    MaxIdleConns: 10,  // 最多保持10个空闲连接
}
```

**建议值：** 通常是 `MaxOpenConns` 的 10%-20%

#### ConnMaxLifetime

连接最大生命周期。超过此时间的连接会被关闭并重新创建。

```go
&core.Options{
    ConnMaxLifetime: time.Hour,  // 连接使用1小时后关闭
}
```

**建议值：**
- 开发环境：`time.Hour`
- 生产环境：`30 * time.Minute` 到 `2 * time.Hour`

#### MaxRetries

连接失败时的最大重试次数。

```go
&core.Options{
    MaxRetries: 3,  // 连接失败后最多重试3次
}
```

#### RetryDelay

重试之间的延迟时间。

```go
&core.Options{
    RetryDelay: time.Second,  // 每次重试等待1秒
}
```

## 连接池配置示例

### 开发环境

```go
devOpts := &core.Options{
    MaxOpenConns:    10,
    MaxIdleConns:    5,
    ConnMaxLifetime: time.Hour,
    MaxRetries:      3,
    RetryDelay:      time.Second,
}
```

### 生产环境

```go
prodOpts := &core.Options{
    MaxOpenConns:    100,
    MaxIdleConns:    20,
    ConnMaxLifetime: 30 * time.Minute,
    MaxRetries:      5,
    RetryDelay:      2 * time.Second,
}
```

### 高并发环境

```go
highConcurrencyOpts := &core.Options{
    MaxOpenConns:    500,
    MaxIdleConns:    50,
    ConnMaxLifetime: 15 * time.Minute,
    MaxRetries:      3,
    RetryDelay:      time.Second,
}
```

## DSN（数据源名称）详解

### MySQL DSN 格式

```go
// 基本格式
"user:password@tcp(host:port)/dbname"

// 完整格式
"user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=true&loc=Local"

// 带超时设置
"user:password@tcp(127.0.0.1:3306)/dbname?timeout=10s&readTimeout=30s&writeTimeout=30s"

// 常用参数
- charset=utf8mb4     // 字符集
- parseTime=true      // 解析时间类型
- loc=Local           // 时区
- timeout=10s         // 连接超时
- readTimeout=30s     // 读超时
- writeTimeout=30s    // 写超时
- multiStatements=true // 允许执行多条语句
```

### PostgreSQL DSN 格式

```go
// 基本格式
"host=localhost port=5432 user=postgres dbname=app sslmode=disable"

// 完整格式
"host=localhost port=5432 user=postgres password=secret dbname=app sslmode=disable connect_timeout=10"

// 常用参数
- host=localhost           // 主机
- port=5432               // 端口
- user=postgres           // 用户名
- password=secret          // 密码
- dbname=app              // 数据库名
- sslmode=disable         // SSL模式：disable, require, verify-ca, verify-full
- connect_timeout=10       // 连接超时（秒）
- timezone=Asia/Shanghai   // 时区
```

### SQLite DSN 格式

```go
// 文件路径
"./app.db"
"/path/to/database.db"

// 内存数据库
":memory:"

// 共享缓存模式
"file:test.db?cache=shared&_journal_mode=WAL"

// 常用参数
- cache=shared         // 共享缓存
- _journal_mode=WAL    // 写前日志模式
- _timeout=5000        // 忙等待超时（毫秒）
```

## 连接状态检查

### Ping 测试

```go
err := db.Ping()
if err != nil {
    panic("数据库连接失败: " + err.Error())
}
fmt.Println("数据库连接正常")
```

### 定期健康检查

```go
import "time"

ticker := time.NewTicker(30 * time.Second)
go func() {
    for range ticker.C {
        if err := db.Ping(); err != nil {
            fmt.Printf("数据库连接异常: %v\n", err)
        }
    }
}()
```

## 连接错误处理

### 重试机制

jorm 内置了连接重试机制：

```go
opts := &core.Options{
    MaxRetries: 5,        // 最多重试5次
    RetryDelay: time.Second,
}

db, err := core.Open("mysql", "user:password@/dbname", opts)
if err != nil {
    // 重试5次后仍然失败
    panic("无法连接数据库")
}
```

### 错误类型

```go
import (
    "errors"
    "github.com/shrek82/jorm/core"
)

db, err := core.Open("mysql", "user:password@/dbname", opts)
if err != nil {
    if errors.Is(err, core.ErrConnectionFailed) {
        fmt.Println("数据库连接失败")
    } else {
        fmt.Println("其他错误:", err)
    }
}
```

## 关闭连接

使用 `defer` 确保连接被正确关闭：

```go
db, err := core.Open("mysql", "user:password@/dbname", opts)
if err != nil {
    panic(err)
}
defer db.Close()  // 程序退出前关闭连接
```

## 多数据库连接

可以同时连接多个数据库：

```go
// 主数据库
masterDB, err := core.Open("mysql", "user:password@master-host/dbname", opts)
if err != nil {
    panic(err)
}
defer masterDB.Close()

// 从数据库
slaveDB, err := core.Open("mysql", "user:password@slave-host/dbname", opts)
if err != nil {
    panic(err)
}
defer slaveDB.Close()

// 写操作使用主库
masterDB.Model(&User{}).Insert(user)

// 读操作使用从库
slaveDB.Model(&User{}).Where("id = ?", id).First(&user)
```

## 动态切换数据库

```go
var currentDB *core.DB

func setDatabase(dbType string, dsn string) error {
    var err error
    currentDB, err = core.Open(dbType, dsn, opts)
    return err
}

// 切换到 MySQL
setDatabase("mysql", "user:password@/mysql_db")

// 切换到 PostgreSQL
setDatabase("postgres", "user=postgres dbname=postgres_db")
```

## 最佳实践

### 1. 使用连接池

合理配置连接池可以显著提高性能：

```go
// 推荐
&core.Options{
    MaxOpenConns:    100,
    MaxIdleConns:    20,
    ConnMaxLifetime: 30 * time.Minute,
}

// 不推荐：不使用连接池
&core.Options{
    MaxOpenConns: 1,  // 会导致连接竞争
}
```

### 2. 设置合理的超时

```go
// 推荐：设置超时
"user:password@tcp(127.0.0.1:3306)/dbname?timeout=10s"

// 不推荐：没有超时设置
"user:password@tcp(127.0.0.1:3306)/dbname"
```

### 3. 使用 defer Close()

```go
db, err := core.Open("mysql", "user:password@/dbname", opts)
if err != nil {
    panic(err)
}
defer db.Close()  // 确保连接被关闭
```

### 4. 监控连接池状态

定期检查连接池健康状况：

```go
stats := db.Stats()
fmt.Printf("打开的连接数: %d\n", stats.OpenConnections)
fmt.Printf("空闲连接数: %d\n", stats.Idle)
fmt.Printf("等待连接数: %d\n", stats.WaitCount)
```

## 故障排查

### 连接失败

```go
db, err := core.Open("mysql", "user:password@/dbname", opts)
if err != nil {
    // 检查以下内容：
    // 1. 数据库服务是否启动
    // 2. 主机和端口是否正确
    // 3. 用户名和密码是否正确
    // 4. 数据库是否存在
    // 5. 网络是否可达
    panic(err)
}
```

### 连接泄露

如果遇到连接泄露，检查：

1. 是否使用了 `defer db.Close()`
2. 是否正确关闭了 `*sql.Rows` 和 `*sql.Tx`
3. `ConnMaxLifetime` 是否设置得太短

```go
// 不正确的写法
rows, _ := db.Query("SELECT * FROM users")
// 忘记关闭 rows，会导致连接泄露

// 正确的写法
rows, err := db.Query("SELECT * FROM users")
if err != nil {
    return err
}
defer rows.Close()  // 必须关闭
```

### 连接池耗尽

如果连接池耗尽，检查：

1. `MaxOpenConns` 是否设置得太小
2. 是否有查询没有及时释放连接
3. 是否有慢查询占用连接时间过长

```go
// 增加 MaxOpenConns
&core.Options{
    MaxOpenConns: 200,  // 增加最大连接数
}
```

## 下一步

- [模型定义](./03-模型定义.md) - 了解如何定义数据模型
- [日志配置](./13-日志配置.md) - 配置日志以调试连接问题
- [性能优化](./17-性能优化.md) - 优化数据库连接性能
