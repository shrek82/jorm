# 待优化清单 (Performance & Architecture)

本文档列出了当前 JORM 架构中可进一步优化性能、提升代码优雅度的方向。暂时不需要开发，仅作为架构演进的参考。

## 1. 核心性能优化 (Performance)

### 1.1 SQL 构建器 (Builder) 零内存分配优化 [x]
- **现状**: `core/builder.go` 中 `BuildSelect`, `BuildUpdate` 等方法大量使用 `[]string` 切片 append 和 `strings.Join` 来拼接 SQL。
- **优化**: 使用 `strings.Builder` 替换切片拼接。`strings.Builder` 底层直接写入 buffer，减少了切片扩容和中间字符串的内存分配。
- **预估收益**: SQL 构建阶段内存分配减少 50% 以上，CPU 占用降低。

### 1.2 TimeScanner 内存优化
- **现状**: `core/query.go` 中的 `TimeScanner.parse` 方法在每次被调用时都会重新定义 `layouts := []string{...}` 切片。
- **优化**: 将 `layouts` 提取为包级全局变量（或常量数组），避免每次扫描时间字段时都分配新的切片。
- **预估收益**: 消除时间字段扫描时的切片分配开销。

### 1.3 Query 对象池化 (Object Pooling)
- **现状**: 每次调用 `db.Model()` 或 `db.Table()` 都会创建一个新的 `*Query` 对象。
- **优化**: 使用 `sync.Pool` 复用 `Query` 对象。在 `PutQuery` 时重置 `builder`, `model`, `ctx` 等字段。
- **预估收益**: 高并发场景下显著减少 GC 压力。

### 1.4 Hook 检测缓存 [x]
- **现状**: 每次执行增删改查时，都会通过 `value.(BeforeInserter)` 等类型断言来检查是否实现了 Hook 接口。
- **优化**: 在 `model.GetModel` 解析模型元数据时，预先检查并缓存该 Model 是否实现了各类 Hook 接口（例如在 `Model` 结构体中增加 `HasBeforeInsert bool` 字段）。
- **预估收益**: 运行时减少反射/类型断言开销。

### 1.5 错误判断优化
- **现状**: `core/db.go` 中的 `reportError` 使用 `strings.Contains` 匹配错误字符串来判断是否为连接错误。
- **优化**: 使用 `errors.Is` 或 `errors.As` 配合数据库驱动特定的错误类型进行判断，或者定义标准化的错误常量。
- **预估收益**: 提高错误判断的准确性和性能，避免魔术字符串。

## 2. 架构与代码优雅度 (Elegance)

### 2.1 扫描计划缓存 (Scan Plan Cache)
- **现状**: `getScanPlan` 每次查询都会重新计算列名到结构体字段的映射关系。
- **优化**: 引入 `ScanPlan` 缓存。根据 `Model` 类型和 `SQL结果集列名hash` 作为 Key 缓存扫描计划。
- **收益**: 对于重复执行的相同查询，消除列映射计算开销。

### 2.2 减少反射创建 (Reduce Reflection)
- **现状**: `scanRowWithPlan` 内部循环中，对非特殊类型字段使用 `reflect.New(field.Type).Interface()` 创建新指针。
- **优化**: 探索使用预分配的 `[]interface{}` 缓冲区，或者针对基础类型使用非反射路径（如果可能）。
- **收益**: 降低大结果集扫描时的内存分配速率。

### 2.3 Functional Options 模式
- **现状**: `core.Options` 使用结构体传递配置。
- **优化**: 改为 Functional Options 模式（如 `jorm.Open(dsn, jorm.WithMaxIdleConns(10))`），使配置扩展更灵活且向后兼容。

### 2.4 Context 传递规范化
- **现状**: `Query` 结构体持有 `ctx`，但部分底层方法可能依赖闭包或结构体字段。
- **优化**: 确保所有底层 `Executor` 方法（`QueryContext`, `ExecContext`）严格接受 `context.Context` 作为第一个参数，保持 Go 语言的最佳实践。

## 3. 测试与验证
- **基准测试**: 针对上述优化点，需编写 Benchmark（如 `BenchmarkSQLBuilder`, `BenchmarkScan`）来量化优化前后的性能差异。
- **内存分析**: 使用 `pprof` 定位热点，确保优化切实有效。
